<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>(JVM - 二)详解class的加载过程 | buqiugouda的博客主页</title><meta name="author" content="不求勾搭"><meta name="copyright" content="不求勾搭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="详解class的加载过程一、Java从编码到执行首先我们来看一下Java是如何从编码到执行的呢？ 我们有一个x.java文件通过执行javac命令可以变成x.class文件，当我们调用Java命令的时候class文件会被装载到内存中，这个过程叫做classloader。一般情况下我们自己写代码的时候会用到Java的类库，所以在加载的时候也会把Java类库相关的类也加载到内存中。装载完成之后会调用字">
<meta property="og:type" content="article">
<meta property="og:title" content="(JVM - 二)详解class的加载过程">
<meta property="og:url" content="https://buqiugouda.github.io/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="buqiugouda的博客主页">
<meta property="og:description" content="详解class的加载过程一、Java从编码到执行首先我们来看一下Java是如何从编码到执行的呢？ 我们有一个x.java文件通过执行javac命令可以变成x.class文件，当我们调用Java命令的时候class文件会被装载到内存中，这个过程叫做classloader。一般情况下我们自己写代码的时候会用到Java的类库，所以在加载的时候也会把Java类库相关的类也加载到内存中。装载完成之后会调用字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://buqiugouda.github.io/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/Jvm%E8%B0%83%E4%BC%98.jpg">
<meta property="article:published_time" content="2019-08-21T10:24:50.000Z">
<meta property="article:modified_time" content="2023-01-28T15:04:00.187Z">
<meta property="article:author" content="不求勾搭">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://buqiugouda.github.io/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/Jvm%E8%B0%83%E4%BC%98.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://buqiugouda.github.io/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '(JVM - 二)详解class的加载过程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-28 23:04:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://portrait.gitee.com/uploads/avatars/user/196/590832_buqiugouda_1620800091.png!avatar200" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/Jvm%E8%B0%83%E4%BC%98.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="buqiugouda的博客主页"><span class="site-name">buqiugouda的博客主页</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">(JVM - 二)详解class的加载过程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-21T10:24:50.000Z" title="发表于 2019-08-21 18:24:50">2019-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-28T15:04:00.187Z" title="更新于 2023-01-28 23:04:00">2023-01-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JVM%E8%B0%83%E4%BC%98/">JVM调优</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="详解class的加载过程"><a href="#详解class的加载过程" class="headerlink" title="详解class的加载过程"></a>详解class的加载过程</h1><h2 id="一、Java从编码到执行"><a href="#一、Java从编码到执行" class="headerlink" title="一、Java从编码到执行"></a>一、Java从编码到执行</h2><p>首先我们来看一下Java是如何从编码到执行的呢？ 我们有一个x.java文件通过执行javac命令可以变成x.class文件，当我们调用Java命令的时候class文件会被装载到内存中，这个过程叫做classloader。一般情况下我们自己写代码的时候会用到Java的类库，所以在加载的时候也会把Java类库相关的类也加载到内存中。装载完成之后会调用字节码解释器和JIT即时编译器来进行解释和编译，编译完之后由执行引擎开始执行，执行引擎下面对应的就是操作系统硬件了。下图是大体的流程：</p>
<span id="more"></span>
<p><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-05-32.png"></p>
<p>Java叫做跨平台的语言，JVM可以称之为跨语言的平台；</p>
<!--more-->
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>1.解释器： bytecode intepreter</p>
<p>2.jit：just in-time compiler</p>
<p>3.混合模式：</p>
<p>混合使用解释器+热点代码编译 进行组合，起始阶段采用解释执行<br>热点代码检测 -多次被调用的代码 - 多次被调用的循环 -进行本地编译<br>-Xmixd :默认为混合模式，启动速度较快，对热点代码实行检测和编译；<br>-Xint:使用纯解释模式，启动很快，执行稍慢 ；<br>-Xcomp:  使用纯编译模式，执行很快，启动稍慢。</p>
<p>有个问题:java是解释执行还是编译执行？</p>
<blockquote>
<p>答：解释和编译是可以混合的，特别常用的代码或者是代码用到的次数特别多的时候，会把一个即时编译做成本地编译，这样会很大程度上的提高效率。</p>
</blockquote>
<p>Java虚拟机是如何做到这么多语言都可以在上面运行，关键在于class文件，任何语言只要能编译成class文件，并且符合class文件的规范你就可以放在Java虚拟机上去运行。</p>
<h2 id="二、详解class文件的加载过程"><a href="#二、详解class文件的加载过程" class="headerlink" title="二、详解class文件的加载过程"></a>二、详解class文件的加载过程</h2><p>接下来主要讲的是一个class文件是怎么从硬盘上到内存中，并开始执行的。</p>
<p>类加载主要有三个过程：loading 、linking 、initializing；其中linking又分为三个步骤：verification 、preparation 、resolution；<br><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-09-35.png"></p>
<p>1、首先Loading是什么意思呢？是把一个class文件load到内存中去；</p>
<p>2、接下来是Linking分为了三小步：</p>
<ul>
<li>verification  是用来校验加载进来的class文件是否符合class文件标准，如果不符合直接就会被classloader直接拒绝；</li>
<li>preparation  是将class文件静态变量赋默认值而不是初始值，例如static int i =8；这个步骤并不是将i赋值为8，而是赋值为默认值0；</li>
<li>resolution  是把class文件常量池中用到的符号引用转换成直接内存地址，可以访问到的内容；<br>3、initializing  称为初始化，静态变量在这个时候才会被赋值为初始值；</li>
</ul>
<h2 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h2><h3 id="双亲委派机制概述"><a href="#双亲委派机制概述" class="headerlink" title="双亲委派机制概述"></a>双亲委派机制概述</h3><p>类加载器的加载过程是分成不同的层次来加载的，不同的类加载器来加载不同的class文件，  Bootstrap &gt;Extension&gt;Application&gt;Custom(自定义类加载器)，其遵循的加载策略即是双亲委派机制。</p>
<p>下面为类加载过程(双亲委派)的简化图：<br><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200629165000263-2051250630.png"></p>
<p>1、第一个类加载器的层次为：Bootstrap 称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库。</p>
<p>2、第二个类加载器的层次为：Extension 是用来加载扩展类的，主要负责加载Java的扩展类库,默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar包。</p>
<p>3、第三个类加载器的层次为：Application 又称为系统类加载器,负责在JVM启动时,加载来自在命令java中的classpath或者java.class.path系统属性或者CLASSPATH操作系统属性所指定的JAR类包和类路径。</p>
<p>4、第三个类加载器的层次为：CustomClassLoader(自定义加载器)  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Bootstrap加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> property.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Ext加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property1</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> property1.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------App加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property2</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> property2.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/**输出结果只截取了部分*/</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\resources.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\rt.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\sunrsasign.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jsse.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jce.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jfr.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\classes</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext</span></span><br><span class="line">        <span class="comment">//C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\deploy.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\access-bridge-64.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\cldrdata.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\dnsns.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jaccess.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jfxrt.jar</span></span><br></pre></td></tr></table></figure>

<p>下图为类加载的一个全过程：<br><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200630084433768-1150504306.png"><br>用比较通俗的话来解释这个过程，当有一个类需要被加载时，首先要判断这个类是否已经被加载到内存中。判断加载与否的过程是自下而上的，如果class类有自己定义的类加载器，会先到CustomClassLoader 管理的cache（缓存）中去找是否已经加载，若已加载直接返回结果，否则到上层加载器ApplicationClassLoader的cache中查找，如果已经存在直接返回，如果不存在，到Extension中查找，存在直接返回，不存在继续向父加载器中寻找直到Bootstrap顶层，如果依然没找到，那就是没有加载器加载过这个类。需要委派对应的加载器来加载，上层加载器先看看这个类是否在自己的加载范围内，如果是直接加载返回结果，若不是继续向下委派，以此类推直到最下级，如果最终也没能加载，就会直接抛异常 ClassNotFoundException，这就是双亲委派模式的流程。</p>
<h3 id="理解双亲委派模式"><a href="#理解双亲委派模式" class="headerlink" title="理解双亲委派模式"></a>理解双亲委派模式</h3><p>1、父加载器：不是类加载器的加载器，也不是类加载器的父类加载器（此处意思是没有父类与子类之间的继承关系）。<br>通常会将 BootstrapClassLoader 称为 ExtensionClassLoader 的父加载器；<br>ExtensionClassLoader 称为 ApplicationClassLoader 的父加载器；<br>ApplicationClassLoader 称为 CustomClassLoader 的父加载器；<br>但这个父子关系并不代表着JAVA语法中的继承，而更形象的只是一种语义上的关联，实际就是ClassLoader的类中有一个成员变量parent指向了其关联的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证了父加载器不是加载器的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentAndChild</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//AppClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null  这里AppClassLoader的加载器不是ExtClassLoader  而是Bootstrap</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">appclassLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getClass().getClassLoader();</span><br><span class="line">        System.out.println(appclassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ExtClassLoader   AppClassLoader的父加载器是ExtClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**输出结果*/</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@23fc625e</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException at com.example.demo.classloader.ParentAndChild.main(ParentAndChild.java:22)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、双亲委派：其工作原理的是，如果一个类加载器收到了类加载请求，并不会直接去加载，而是自下而上的向顶层类加载器查找是否已经被加载了，如果被加载就不用进行加载，如果未被加载过，则会自上而下的检查是否属于自己加载的范围，如果属于则加载，如果不属于则向下委托，直到类被加载进来才能叫做成功，如果加载不成功就会抛异常classnotfoundexeption,这就叫做双亲委派。</p>
<p>3、为什么要搞双亲委派模式？</p>
<p>主要是为了安全，这里可以使用反证法，如果任何类加载器都可以把class加载到内存中，我们就可以自定义类加载器来加载Java.lang.string。在打包时可以把密码存储为String对象，偷偷摸摸的把密码发送到自己的邮箱，这样会造成安全问题。</p>
<h2 id="四、自定义类加载器"><a href="#四、自定义类加载器" class="headerlink" title="四、自定义类加载器"></a>四、自定义类加载器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderByHand</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = ClassLoaderByHand.class.getClassLoader().</span><br><span class="line">                loadClass(<span class="string">&quot;com.example.demo.threaddemo.juc_002.Account&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 输出结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//com.example.demo.threaddemo.juc_002.Account</span></span><br></pre></td></tr></table></figure>
<p>代码运行结果可以看出，若要加载一个类你只要调用classLoader中的 loadClass()方法就能把这个类加载到内存中，加载完成之后会给你返回一个Class类的对象。</p>
<p>在硬盘上找到这个类的源码，把它load到内存，与此同时生成一个Class对象，上述的小程序是通过 ClassLoaderByHand 找到他的加载器AppClassLoader 然后调用它的loadClass()方法，让它帮我们把 Account类加载进来，返回一个clazz对象，使用clazz.getName()方法正常返回Account类。</p>
<blockquote>
<p>什么时候我们需要自己定义去加载一个类？</p>
<ul>
<li>热部署时就是先把之前加载的类给干掉 ，然后使用的自定义类加载器来进行重新加载</li>
<li>spring的动态代理，一个新的class 当需要的时候就会把它load到内存中</li>
</ul>
</blockquote>
<h3 id="ClassLoader的源码分析"><a href="#ClassLoader的源码分析" class="headerlink" title="ClassLoader的源码分析"></a>ClassLoader的源码分析</h3><p>我们还是来看一下ClassLoader的源码，加载过程最主要的还是ClassLoader中的loaderClass()方法：</p>
<p> 结合上面给的类加载过程的图解一起看会更容易一些；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在加载之前先调用findLoadedClass()方法查看是否已经加载过此类</span></span><br><span class="line"><span class="comment">             * 若加载过 返回该对象</span></span><br><span class="line"><span class="comment">             * 如果未加载则返回null 进行下一步</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//判断有无父加载器 如果不为空说明还未到顶层Bootstrap递归调用loadClass()</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果没有父加载器说明调用的加载器为Bootstrap Class Loader, 在此加载器内存中查找是否已经加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若以上的操作都没成功加载此类</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//调用自己的findClass()</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义classLoader"><a href="#自定义classLoader" class="headerlink" title="自定义classLoader"></a>自定义classLoader</h3><p>1.继承ClassLoader抽象类 extends ClassLoader<br>2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int off, int len)<br>3.加密（可以对class字节码文件进行加密处理，可选）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.FileUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.log.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 继承ClassLoader抽象类 extends ClassLoader</span></span><br><span class="line"><span class="comment"> * 2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int</span></span><br><span class="line"><span class="comment"> * 3.加密（可以对class字节码文件进行加密处理，可选）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0B10110110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 findClass 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.myclass&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != <span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b ^ seed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//defineClass最终将二进制流转换为Class类对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对旧class文件的处理,可选，此方法中使用按位取反</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classFileBasePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classPackagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encFile</span><span class="params">(String classFileBasePath, String classPackagePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePahtWithoutSuffix</span> <span class="operator">=</span> classFileBasePath.concat(<span class="string">&quot;/&quot;</span>).concat(classPackagePath.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//旧的class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">oldFis1</span> <span class="operator">=</span> FileUtil.getInputStream(oldClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.myclass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">newFos</span> <span class="operator">=</span> FileUtil.getOutputStream(newClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (oldFis1.read() != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//按位取反</span></span><br><span class="line">            newFos.write(b ^ seed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldFis1.close();</span><br><span class="line">        newFos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        encFile(classFileBasePath, classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> (Hello) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        h.sayHello();</span><br><span class="line"></span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l是由&#123;&#125;加载而来&quot;</span>, l.getClass().getClassLoader());</span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l的父加载器是&#123;&#125;&quot;</span>, l.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、破坏双亲委派机制"><a href="#五、破坏双亲委派机制" class="headerlink" title="五、破坏双亲委派机制"></a>五、破坏双亲委派机制</h2><p>1.如何破坏双亲委派模型？</p>
<p>通过重写loadClass()方法。</p>
<p>2.什么时候破坏过双亲委派模型？</p>
<blockquote>
<ul>
<li>JDK1.2之前，自定义classLoader都必须重写loadClass ()方法。（缺陷）</li>
<li>ThreadContextClassLoader可以实现基础类调用实现类的代码</li>
<li>热启动/热部署  tomcat 都有自己的模块指定classLoader（可以加载同一类库的不同版本）</li>
</ul>
</blockquote>
<p>当下也就只能对自定义的class实现打破双亲委派的策略来加载</p>
<p>破坏双亲委派模型的简单实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重新loadClass方法来打破双亲委派机制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li on 2020/9/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.tiny.security.util.Hello cannot be cast to com.tiny.security.util.Hello</span></span><br><span class="line">        <span class="comment">//Hello h1old = (Hello) clazz.newInstance();</span></span><br><span class="line">        <span class="comment">//h1old.sayHello();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h1</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h1.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在此处断点后，修改hello方法中的输出内容，并重新编译生成新的class</span></span><br><span class="line"><span class="comment">            观察两次输出的内容,可以判定class是否被重新加载了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> l2.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h2</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz2.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h2.sayHello();</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>

<blockquote>
<p>原文/参考链接<br>calss 加载过程: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongl961230/p/13212080.html">https://www.cnblogs.com/dongl961230/p/13212080.html</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://buqiugouda.github.io">不求勾搭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://buqiugouda.github.io/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">https://buqiugouda.github.io/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://buqiugouda.github.io" target="_blank">buqiugouda的博客主页</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/Jvm%E8%B0%83%E4%BC%98.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/" title="hexo 使用配置"><img class="cover" src="/img/covers/cover1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hexo 使用配置</div></div></a></div><div class="next-post pull-right"><a href="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" title="区域截图异常问题排查"><img class="cover" src="/img/covers/note.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">区域截图异常问题排查</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://portrait.gitee.com/uploads/avatars/user/196/590832_buqiugouda_1620800091.png!avatar200" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">不求勾搭</div><div class="author-info__description">路漫漫其修远兮，吾将上下而求索！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/buqiugouda"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">嗨害嗨，来啦😊。<br>这里有一些个人编写、收集的一些随笔，只是我用来翻看的内容。如有侵权可以联系我</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">详解class的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E4%BB%8E%E7%BC%96%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">一、Java从编码到执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">混合模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%A6%E8%A7%A3class%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、详解class文件的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">三、双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">双亲委派机制概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">理解双亲委派模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">四、自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">ClassLoader的源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89classLoader"><span class="toc-number">1.4.2.</span> <span class="toc-text">自定义classLoader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">五、破坏双亲委派机制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/22/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/" title="hexo 使用主题butterfly">hexo 使用主题butterfly</a><time datetime="2021-05-22T11:20:50.000Z" title="发表于 2021-05-22 19:20:50">2021-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/" title="hexo 使用配置">hexo 使用配置</a><time datetime="2021-05-21T10:24:50.000Z" title="发表于 2021-05-21 18:24:50">2021-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" title="(JVM - 二)详解class的加载过程">(JVM - 二)详解class的加载过程</a><time datetime="2019-08-21T10:24:50.000Z" title="发表于 2019-08-21 18:24:50">2019-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" title="区域截图异常问题排查">区域截图异常问题排查</a><time datetime="2019-07-21T08:54:46.000Z" title="发表于 2019-07-21 16:54:46">2019-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/" title="springboot-静态页面无法加载">springboot-静态页面无法加载</a><time datetime="2019-07-01T02:31:35.000Z" title="发表于 2019-07-01 10:31:35">2019-07-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/Jvm%E8%B0%83%E4%BC%98.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 <i id="heartbeat" class="fa fas fa-heartbeat"></i> By 不求勾搭</div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>