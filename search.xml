<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql面试集 - (七) 锁篇</title>
      <link href="/myblog/2020/03/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%207.%E9%94%81/"/>
      <url>/myblog/2020/03/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%207.%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要加锁"><a href="#为什么要加锁" class="headerlink" title="为什么要加锁?"></a>为什么要加锁?</h2><p>当多个用户并发地存取数据时，在<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><p>保证多用户环境下保证数据库完整性和一致性。</p><h2 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p>行级锁</p><ul><li>行级锁是<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</li><li>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul><p>表级锁</p><ul><li>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</li><li>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ul><p>页级锁</p><ul><li>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</li><li>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><h2 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h2><p>从锁的类别上来讲，有共享锁和排他锁。</p><ul><li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li><li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li></ul><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h2 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</li></ul><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h2 id="InnoDB引擎的行锁是怎么实现的？"><a href="#InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="InnoDB引擎的行锁是怎么实现的？"></a>InnoDB引擎的行锁是怎么实现的？</h2><p>InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><h2 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h2 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h2><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p><h2 id="优化锁方面的意见？"><a href="#优化锁方面的意见？" class="headerlink" title="优化锁方面的意见？"></a>优化锁方面的意见？</h2><ul><li>使用较低的隔离级别</li><li>设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突</li><li>选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁</li><li>不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。</li><li>尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别</li><li>对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。</li></ul><hr><blockquote><p><strong>参考地址</strong><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a><br><a href="https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html">https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html</a><br><a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a><br><a href="https://www.jianshu.com/p/05da0fc0950e">https://www.jianshu.com/p/05da0fc0950e</a><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql面试集 - (六) 读写分离篇</title>
      <link href="/myblog/2020/03/25/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%206.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/myblog/2020/03/25/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%206.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是MySQL主从同步？"><a href="#什么是MySQL主从同步？" class="headerlink" title="什么是MySQL主从同步？"></a>什么是MySQL主从同步？</h2><p>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。</p><p>因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。</p><h2 id="MySQL主从同步的目的？为什么要做主从同步？"><a href="#MySQL主从同步的目的？为什么要做主从同步？" class="headerlink" title="MySQL主从同步的目的？为什么要做主从同步？"></a>MySQL主从同步的目的？为什么要做主从同步？</h2><ol><li>通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。</li><li>提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据</li><li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能</li><li>数据备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全</li></ol><h2 id="如何实现MySQL的读写分离？"><a href="#如何实现MySQL的读写分离？" class="headerlink" title="如何实现MySQL的读写分离？"></a>如何实现MySQL的读写分离？</h2><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h2 id="MySQL主从复制流程和原理？"><a href="#MySQL主从复制流程和原理？" class="headerlink" title="MySQL主从复制流程和原理？"></a>MySQL主从复制流程和原理？</h2><p>基本原理流程，是3个线程以及之间的关联</p><p>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p><p>从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p><p>从：sql执行线程——执行relay log中的语句；</p><p><strong>复制过程如下</strong>：</p><p><img src="http://blog-img.coolsen.cn/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU" alt="img"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><h2 id="MySQL主从同步延时问题如何解决？"><a href="#MySQL主从同步延时问题如何解决？" class="headerlink" title="MySQL主从同步延时问题如何解决？"></a>MySQL主从同步延时问题如何解决？</h2><p>MySQL 实际上在有两个同步机制，一个是半同步复制，用来 解决主库数据丢失问题；一个是并行复制，用来 解决主从同步延时问题。</p><ul><li>半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。</li><li>并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</li></ul><hr><blockquote><p><strong>参考地址</strong><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a><br><a href="https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html">https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html</a><br><a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a><br><a href="https://www.jianshu.com/p/05da0fc0950e">https://www.jianshu.com/p/05da0fc0950e</a><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql面试集 - (五) 分库分表篇</title>
      <link href="/myblog/2020/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%205.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/myblog/2020/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%205.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h2><p><strong>分表</strong></p><p>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p><p><strong>分库</strong></p><p>分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p><p>这就是所谓的分库分表。</p><p><img src="https://upload-images.jianshu.io/upload_images/14266602-ae74054f45f44e3d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id="如何对数据库如何进行垂直拆分或水平拆分的？"><a href="#如何对数据库如何进行垂直拆分或水平拆分的？" class="headerlink" title="如何对数据库如何进行垂直拆分或水平拆分的？"></a>如何对数据库如何进行垂直拆分或水平拆分的？</h2><p><strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</p><p><img src="https://upload-images.jianshu.io/upload_images/10089464-0e01dfe246b5c7ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/474/format/webp" alt="img"></p><p><strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><p><img src="https://upload-images.jianshu.io/upload_images/10089464-ab3069913c0f097c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp" alt="img"></p><p>两种<strong>分库分表的方式</strong>：</p><ul><li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li><li>或者是按照某个字段hash一下均匀分散，这个较为常用。</li></ul><p>range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p><p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</p><h2 id="用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？"><a href="#用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？" class="headerlink" title="用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？"></a>用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</h2><p>这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p><p>比较常见的包括：</p><ul><li>cobar<br>阿里 b2b 团队开发和开源的，属于 proxy 层方案。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</li><li>TDDL<br>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</li><li>atlas<br>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</li><li>sharding-jdbc<br>当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</li><li><strong>mycat</strong><br>基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。</li></ul><hr><blockquote><p><strong>参考地址</strong><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a><br><a href="https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html">https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html</a><br><a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a><br><a href="https://www.jianshu.com/p/05da0fc0950e">https://www.jianshu.com/p/05da0fc0950e</a><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql面试集 - (四) 索引篇</title>
      <link href="/myblog/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%204.%E7%B4%A2%E5%BC%95/"/>
      <url>/myblog/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%204.%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。</p><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。</p><h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><p><strong>索引的优点</strong></p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p><strong>索引的缺点</strong></p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><h2 id="MySQL有哪几种索引类型？"><a href="#MySQL有哪几种索引类型？" class="headerlink" title="MySQL有哪几种索引类型？"></a>MySQL有哪几种索引类型？</h2><ol><li>从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</li><li>从应用层次来分：普通索引，唯一索引，复合索引。</li></ol><ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</li><li>非聚簇索引： 不是聚簇索引，就是非聚簇索引</li></ul><ol start="3"><li>根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。</li></ol><h2 id="索引的底层实现-数据结构-？"><a href="#索引的底层实现-数据结构-？" class="headerlink" title="索引的底层实现(数据结构)？"></a>索引的底层实现(数据结构)？</h2><p><strong>Hash索引</strong></p><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210411215012443.png"></p><p><strong>B-Tree索引</strong>（MySQL使用B+Tree）</p><p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210411215023820.png"></p><p><strong>B+Tree索引</strong></p><p>是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p><p>B+tree性质：</p><ul><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ul><p><img src="http://blog-img.coolsen.cn/img/image-20210411215044332.png"></p><h2 id="为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？"><a href="#为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？" class="headerlink" title="为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？"></a>为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h2><p>B-tree： 从两个方面来回答</p><ul><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 <code>IO读写次数就降低</code>了。</li><li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在 <code>区间查询</code>的情况，所以通常B+树用于数据库索引。</li></ul><p>Hash：</p><ul><li>虽然可以快速定位，但是没有顺序，IO复杂度高；</li></ul><ul><li>基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；</li><li>适合<strong>等值查询</strong>，如=、in()、&lt;=&gt;，不支持范围查询 ；</li><li>因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成<a href>排序</a> ；</li><li>Hash索引在查询等值时非常快 ；</li><li>因为Hash索引始终索引的<strong>所有列的全部内容</strong>，所以不支持部分索引列的匹配查找 ；</li><li>如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。</li></ul><p>二叉树： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p><p>红黑树： 树的高度随着数据量增加而增加，IO代价高。</p><h2 id="讲一讲聚簇索引与非聚簇索引？"><a href="#讲一讲聚簇索引与非聚簇索引？" class="headerlink" title="讲一讲聚簇索引与非聚簇索引？"></a>讲一讲聚簇索引与非聚簇索引？</h2><p>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。</p><p>而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。</p><p>聚簇索引与非聚簇索引的区别：</p><ul><li>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）</li><li>对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为<strong>回表</strong>。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。</li><li>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可</li><li>注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。</li></ul><h2 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h2><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为”覆盖索引”。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 <code>select score from student where score &gt; 90</code>的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。</p><h2 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h2><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h2 id="讲一讲MySQL的最左前缀原则"><a href="#讲一讲MySQL的最左前缀原则" class="headerlink" title="讲一讲MySQL的最左前缀原则?"></a>讲一讲MySQL的最左前缀原则?</h2><p>最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。<br>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><h2 id="讲一讲前缀索引？"><a href="#讲一讲前缀索引？" class="headerlink" title="讲一讲前缀索引？"></a>讲一讲前缀索引？</h2><p>因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。</p><p> 流程是：</p><p> 先计算完整列的选择性 :<code>select count(distinct col_1)/count(1) from table_1</code></p><p> 再计算不同前缀长度的选择性 :<code>select count(distinct left(col_1,4))/count(1) from table_1 </code></p><p> 找到最优长度之后，创建前缀索引 :<code> create index idx_front on table_1 (col_1(4))</code></p><h2 id="了解索引下推吗？"><a href="#了解索引下推吗？" class="headerlink" title="了解索引下推吗？"></a>了解索引下推吗？</h2><p>MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。</p><ul><li>有了索引下推优化，可以在<strong>减少回表次数</strong></li><li>在InnoDB中只针对二级索引有效</li></ul><p>官方文档中给的例子和解释如下：</p><p>在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;</p><ul><li>如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件</li><li>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。</li></ul><h2 id="怎么查看MySQL语句有没有用到索引？"><a href="#怎么查看MySQL语句有没有用到索引？" class="headerlink" title="怎么查看MySQL语句有没有用到索引？"></a>怎么查看MySQL语句有没有用到索引？</h2><p>通过explain，如以下例子：</p><p><code>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#39;10001&#39; AND title=&#39;Senior Engineer&#39; AND from_date=&#39;1986-06-26&#39;;</code></p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>filtered</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>titles</td><td>null</td><td>const</td><td>PRIMARY</td><td>PRIMARY</td><td>59</td><td>const,const,const</td><td>10</td><td>1</td><td></td></tr></tbody></table><ul><li><p>id：在⼀个⼤的查询语句中每个<strong>SELECT</strong>关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = ‘egon1’);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。</p></li><li><p>select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。</p></li><li><p>table：每个查询对应的表名 。</p></li><li><p>type：<code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。</p><p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p></li><li><p>possible_key：查询中可能用到的索引*(可以把用不到的删掉，降低优化器的优化时间)* 。</p></li><li><p>key：此字段是 MySQL 在当前查询时所真正使用到的索引。</p></li><li><p>filtered：查询器预测满足下一次查询条件的百分比 。</p></li><li><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p></li><li><p>extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。</p></li></ul><h2 id="为什么官方建议使用自增长主键作为索引？"><a href="#为什么官方建议使用自增长主键作为索引？" class="headerlink" title="为什么官方建议使用自增长主键作为索引？"></a>为什么官方建议使用自增长主键作为索引？</h2><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</p><p>插入连续的数据：</p><p><img src="http://blog-img.coolsen.cn/img/java10-1562726251.gif"></p><p>插入非连续的数据：</p><p><img src="http://blog-img.coolsen.cn/img/java8-1562726251.gif"></p><h2 id="如何创建索引？"><a href="#如何创建索引？" class="headerlink" title="如何创建索引？"></a>如何创建索引？</h2><p>创建索引有三种方式。</p><ol><li>在执行CREATE TABLE时创建索引</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">id <span class="type">INT</span> auto_increment <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">first_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">last_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">id_card <span class="type">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">information text,</span><br><span class="line">KEY name (first_name, last_name),</span><br><span class="line">FULLTEXT KEY (information),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY (id_card)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用ALTER TABLE命令去增加索引。</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column_list);</span><br></pre></td></tr></table></figure><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。<br>3. 使用CREATE INDEX命令创建。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure><h2 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h2><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h2 id="建索引的原则有哪些？"><a href="#建索引的原则有哪些？" class="headerlink" title="建索引的原则有哪些？"></a>建索引的原则有哪些？</h2><ol><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li><li>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li><li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol><h2 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h2><p>通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p><ul><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。</li><li>基于非唯一性索引的检索。</li></ul><h2 id="什么情况下不走索引（索引失效）？"><a href="#什么情况下不走索引（索引失效）？" class="headerlink" title="什么情况下不走索引（索引失效）？"></a>什么情况下不走索引（索引失效）？</h2><ol><li>使用!= 或者 &lt;&gt; 导致索引失效</li><li>类型不一致导致的索引失效</li><li>函数导致的索引失效<br>如：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> <span class="type">DATE</span>(create_time) <span class="operator">=</span> <span class="string">&#x27;2020-09-03&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果使用函数在索引列，这是不走索引的。</p><ol start="4"><li>运算符导致的索引失效</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> age <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。</p><ol start="5"><li>OR引起的索引失效</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">OR</span> height <span class="operator">=</span> <span class="string">&#x27;175&#x27;</span>;</span><br></pre></td></tr></table></figure><p>OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p><ol start="6"><li>模糊搜索导致的索引失效</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%冰&#x27;</span>;</span><br></pre></td></tr></table></figure><p>当 <code>%</code>放在匹配字段前是不走索引的，放在后面才会走索引。</p><ol start="7"><li>NOT IN、NOT EXISTS导致索引失效</li></ol><hr><blockquote><p>参考链接<br><a href="https://www.javazhiyin.com/40232.html">https://www.javazhiyin.com/40232.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql面试集 - (三) Mysql优化</title>
      <link href="/myblog/2020/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%203.%E4%BC%98%E5%8C%96/"/>
      <url>/myblog/2020/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%203.%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="如何定位及优化SQL语句的性能问题？"><a href="#如何定位及优化SQL语句的性能问题？" class="headerlink" title="如何定位及优化SQL语句的性能问题？"></a>如何定位及优化SQL语句的性能问题？</h2><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。</p><p> 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。<br><img src="http://blog-img.coolsen.cn/img/image-20210822204026552.png" alt="image-20210822204026552"></p><h2 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h2><ul><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ul><h2 id="超大分页怎么处理"><a href="#超大分页怎么处理" class="headerlink" title="超大分页怎么处理?"></a>超大分页怎么处理?</h2><p>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于 <code>select * from table where age &gt; 20 limit 1000000</code>,10 这种查询其实也是有可以优化的余地的. 这条语句需要 load1000000 数据然后基本上全部丢弃,只取 10 条当然比较慢. 当时我们可以修改为 <code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也 load 了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。</p><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><blockquote><p>【推荐】利用延迟关联或者子查询优化超多分页场景。</p><p>说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</p><p>正例：先快速定位需要获取的id段，然后再关联：</p><p>SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p></blockquote><h2 id="统计过慢查询吗？对慢查询都怎么优化过？"><a href="#统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="统计过慢查询吗？对慢查询都怎么优化过？"></a>统计过慢查询吗？对慢查询都怎么优化过？</h2><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p><p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p><p>所以优化也是针对这三个方向来的，</p><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h2 id="如何优化查询过程中的数据访问"><a href="#如何优化查询过程中的数据访问" class="headerlink" title="如何优化查询过程中的数据访问"></a>如何优化查询过程中的数据访问</h2><ul><li>访问数据太多导致查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认MySQL服务器是否在分析大量不必要的数据行</li><li>查询不需要的数据。解决办法：使用limit解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>是否在扫描额外的记录。解决办法：<br>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：<br>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul><h2 id="如何优化关联查询"><a href="#如何优化关联查询" class="headerlink" title="如何优化关联查询"></a>如何优化关联查询</h2><ul><li>确定ON或者USING子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h2 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h2><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ol><li><strong>将字段很多的表分解成多个表</strong></li></ol><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><ol start="2"><li><strong>增加中间表</strong></li></ol><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><ol start="3"><li><strong>增加冗余字段</strong></li></ol><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p>注意：</p><p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</p><h2 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h2><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 MySQLd 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 MySQLd 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</p><h2 id="大表怎么优化？"><a href="#大表怎么优化？" class="headerlink" title="大表怎么优化？"></a>大表怎么优化？</h2><p>类似的问题：某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</p><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ul><li>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li><li>读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</li><li>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑；</li><li>通过分库分表的方式进行优化，主要有垂直分表和水平分表。</li></ul><hr><blockquote><p><strong>参考地址</strong><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a><br><a href="https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html">https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html</a><br><a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a><br><a href="https://www.jianshu.com/p/05da0fc0950e">https://www.jianshu.com/p/05da0fc0950e</a><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql面试集 - (二) 事务篇</title>
      <link href="/myblog/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%202.%E4%BA%8B%E5%8A%A1/"/>
      <url>/myblog/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%202.%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h2 id="介绍一下事务具有的四个特征"><a href="#介绍一下事务具有的四个特征" class="headerlink" title="介绍一下事务具有的四个特征"></a>介绍一下事务具有的四个特征</h2><p>事务就是一组原子性的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。</p><ul><li>原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</li><li>一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li><li>隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的//操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li></ul><h2 id="说一下MySQL-的四种隔离级别"><a href="#说一下MySQL-的四种隔离级别" class="headerlink" title="说一下MySQL 的四种隔离级别"></a>说一下MySQL 的四种隔离级别</h2><ul><li>Read Uncommitted（读取未提交内容）</li></ul><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><ul><li>Read Committed（读取提交内容）</li></ul><p>这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓 的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。</p><ul><li>Repeatable Read（可重读）</li></ul><p>这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><ul><li>Serializable（可串行化）</li></ul><p>通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210822180308501.png" alt="image-20210822180308501"></p><p>MySQL 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h2 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h2><p>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p><p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p><p>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。</p><h2 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h2><p>事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。</p><p>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。</p><p>每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。</p><h2 id="MySQL事务日志介绍下？"><a href="#MySQL事务日志介绍下？" class="headerlink" title="MySQL事务日志介绍下？"></a>MySQL事务日志介绍下？</h2><p>innodb 事务日志包括 redo log 和 undo log。</p><p>undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。</p><p>事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。</p><p>redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210822181340692.png" alt="image-20210822181340692"></p><p>undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210822181416382.png" alt="image-20210822181416382"></p><h2 id="什么是MySQL的-binlog？"><a href="#什么是MySQL的-binlog？" class="headerlink" title="什么是MySQL的 binlog？"></a>什么是MySQL的 binlog？</h2><p>MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。</p><p>MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。</p><p>binlog 有三种格式，各有优缺点：</p><ul><li><strong>statement：</strong> 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。</li><li><strong>row：</strong> 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。</li><li><strong>mixed：</strong> 混合模式，根据语句来选用是 statement 还是 row 模式。</li></ul><p>##. 在事务中可以混合使用存储引擎吗？**</p><p>尽量不要在同一个事务中使用多种存储引擎，MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。</p><p>如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表）,在正常提交的情况下不会有什么问题。</p><p>但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p><h2 id="MySQL中是如何实现事务隔离的"><a href="#MySQL中是如何实现事务隔离的" class="headerlink" title="MySQL中是如何实现事务隔离的?"></a>MySQL中是如何实现事务隔离的?</h2><p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p><p>MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p><p>详细原理看这篇文章：<a href="https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html">https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html</a></p><h2 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h2><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><h2 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a>MVCC 的实现原理</h2><p>对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：</p><ul><li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li><li>事务 ID：记录最后一次修改该记录的事务 ID。</li><li>回滚指针：指向这条记录的上一个版本。</li></ul><p>我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：</p><p><img src="http://blog-img.coolsen.cn/img/modb_95751916-225c-11eb-b0bb-5254001c05fe.png" alt="img"></p><p>如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：</p><ul><li>数据库会先对满足 a=1 的行加排他锁；</li><li>然后将原记录复制到 undo 表空间中；</li><li>修改 b 字段的值为 666，修改事务 ID 为 2；</li><li>并通过隐藏的回滚指针指向 undo log 中的历史记录；</li><li>事务提交，释放前面对满足 a=1 的行所加的排他锁。</li></ul><p>在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是<strong>来自 undolog</strong> 中。</p><p>因此可以总结出 MVCC 实现的原理大致是：</p><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p><hr><blockquote><p><strong>参考地址</strong><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a><br><a href="https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html">https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html</a><br><a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a><br><a href="https://www.jianshu.com/p/05da0fc0950e">https://www.jianshu.com/p/05da0fc0950e</a><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql面试集 - (一) 基础篇</title>
      <link href="/myblog/2020/03/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%201.%E5%9F%BA%E7%A1%80/"/>
      <url>/myblog/2020/03/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/Mysql/mysql%201.%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h2><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。</p><h2 id="MySQL-执行查询的过程"><a href="#MySQL-执行查询的过程" class="headerlink" title="MySQL 执行查询的过程"></a>MySQL 执行查询的过程</h2><ol><li>客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配</li><li>查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）</li><li>语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</li><li>优化。是否使用索引，生成执行计划。</li><li>交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</li></ol><p><img src="https://static001.geekbang.org/infoq/41/4102b7d60fa20a0caabb127ecbb4d2f3.jpeg?x-oss-process=image/resize%EF%BC%8Cp_80/auto-orient%EF%BC%8C1" alt="img"></p><h2 id="MySQL-支持哪些存储引擎"><a href="#MySQL-支持哪些存储引擎" class="headerlink" title="MySQL 支持哪些存储引擎?"></a>MySQL 支持哪些存储引擎?</h2><p>MySQL 支持多种存储引擎，比如 InnoDB，MyISAM，Memory，Archive 等等.在大多数的情况下，直接选择使用 InnoDB 引擎都是最合适的，InnoDB 也是 MySQL 的默认存储引擎。</p><table><thead><tr><th align="left"></th><th>InnoDb</th><th>MyiSAM</th></tr></thead><tbody><tr><td align="left">事务</td><td>支持</td><td>不支持</td></tr><tr><td align="left">外键</td><td>支持</td><td>不支持</td></tr><tr><td align="left">全文索引</td><td>不支持</td><td>支持</td></tr><tr><td align="left">索引类型</td><td>聚集索引</td><td>非聚集索引</td></tr><tr><td align="left">全表行数</td><td>不记录</td><td>变量记录</td></tr><tr><td align="left">锁类型</td><td>行级锁、表级锁</td><td>表级锁</td></tr></tbody></table><h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h2><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h2 id="SQL-建表约束有哪几种？"><a href="#SQL-建表约束有哪几种？" class="headerlink" title="SQL 建表约束有哪几种？"></a>SQL 建表约束有哪几种？</h2><ul><li>主键约束（Primay Key Coustraint） 唯一性，非空性</li><li>唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个</li><li>检查约束 (Check Counstraint) 对该列数据的范围、格式的限制</li><li>默认约束 (Default Counstraint) 该数据的默认值</li><li>外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列</li></ul><h2 id="MySQL-中的-varchar和-char有什么区别？"><a href="#MySQL-中的-varchar和-char有什么区别？" class="headerlink" title="MySQL 中的 varchar和 char有什么区别？"></a>MySQL 中的 <code>varchar</code>和 <code>char</code>有什么区别？</h2><p>char 是一个定长字段，假如申请了 <code>char(10)</code>的空间，那么无论实际存储多少内容.该字段都占用 10 个字符，而 varchar 是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度+1，最后一个字符存储使用了多长的空间.</p><p>在检索效率上来讲，char &gt; varchar，因此在使用中，如果确定某个字段的值的长度，可以使用 char，否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码，则应该使用 char。</p><h2 id="MySQL中-in和-exists区别"><a href="#MySQL中-in和-exists区别" class="headerlink" title="MySQL中 in和 exists区别"></a>MySQL中 <code>in</code>和 <code>exists</code>区别</h2><p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><p>如果查询的两个表大小相当，那么用in和exists差别不大。<br>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。<br>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p><h2 id="drop、delete与-truncate的区别"><a href="#drop、delete与-truncate的区别" class="headerlink" title="drop、delete与 truncate的区别"></a><code>drop</code>、<code>delete</code>与 <code>truncate</code>的区别</h2><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th></th><th>Delete</th><th>Truncate</th><th>Drop</th></tr></thead><tbody><tr><td>类型</td><td>属于DML</td><td>属于DDL</td><td>属于DDL</td></tr><tr><td>回滚</td><td>可以回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除部分数据行</td><td>表结构还在，删除全表数据</td><td>从数据库中删除表，包括所有数据行、索引、权限等都会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是一些预编译的 SQL 语句。</p><p>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p><p>2、存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全</p><p>但是，在互联网项目中，其实是不太推荐存储过程的，比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程，我个人的理解是，在互联网项目中，迭代太快，项目的生命周期也比较短，人员流动相比于传统的项目也更加频繁，在这样的情况下，存储过程的管理确实是没有那么方便，同时，复用性也没有写在服务层那么好。</p><hr><blockquote><p><strong>参考地址</strong><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a><br><a href="https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html">https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html</a><br><a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a><br><a href="https://www.jianshu.com/p/05da0fc0950e">https://www.jianshu.com/p/05da0fc0950e</a><br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试集 </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringColud核心组件浅析</title>
      <link href="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/"/>
      <url>/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud包含了众多的组件,涉及了相当多的技术栈,本文只总结一些高频核心组件的使用概念。</p><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675933716545.jpg" alt="1675933716545"></p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>首先虚构一个电商行业业务场景</p><ul><li>创建一个订单，当用户支付了这个订单后，更新订单状态</li><li>扣减订单商品的库存</li><li>通知物流中心发货</li><li>为下单的用户增加积分</li></ul><p>对于上述场景，需要创建 <strong>订单服务</strong>、<strong>库存服务</strong>、<strong>仓库服务</strong>、<strong>积分服务</strong>，运作流程图如下</p><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675931741354.png" alt="1675931741354"></p><h2 id="Eureka-服务注册中心"><a href="#Eureka-服务注册中心" class="headerlink" title="Eureka 服务注册中心"></a>Eureka 服务注册中心</h2><p>首先考虑第一个问题: <code>订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？</code><br>订单服务在不清楚其他服务的地址时，根本无法构造一个请求。而Eureka作为微服务架构中的注册中心，专门负责服务的注册与发现。</p><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675950030085.png" alt="1675950030085"></p><p>如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件负责将自身服务的信息注册到Eureka Server中，Eureka Server中有一个注册表，保存了各服务所在的机器和端口号。</p><p>订单服务里也有一个Eureka Client组件，当订单服务需要访问库存服务时，就会通过Eureka Client组件找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓库服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p><p>小结：</p><ul><li>Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</li><li>Eureka Client：负责将这个服务的信息注册到Eureka Server中，并在需要时拉取Eureka Server的注册信息</li></ul><h2 id="Feign-动态代理"><a href="#Feign-动态代理" class="headerlink" title="Feign 动态代理"></a>Feign 动态代理</h2><p>现在订单服务已经知道库存服务、积分服务、仓库服务的地址信息了。但是新问题又来了，每次订单服务与其他服务的交互，必然涉及到,跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果进行解析。<code>这大量的代码是否存在一种简单的方式去替代呢？</code></p><p>回想下未使用工具类前使用原生java代码发送http请求、附加参数、解析回调等代码，想想都让人打脑壳。而Feign为我们提供了更加优雅的解决方案。示意代码如下。</p><p>库存服务接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;invertory-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InventoryService</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减指定商品的库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value &quot;/reducestock/&#123;goodsskuId&#125;&quot;, method HttpMethod.PUT)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Resultcode <span class="title function_">reducestock</span><span class="params">(<span class="meta">@Pathvariable(&quot;goodsskuId&quot;)</span> Long goodsskuId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单服务使用该接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">orderservice</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Inventoryservice inventoryservice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Resultcode <span class="title function_">payorder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//步骤1：更新本地数据库订单状态为“已支付”</span></span><br><span class="line">        orderDAO.updatestatus(id,orderstatus.PAYED);</span><br><span class="line">        <span class="comment">//步骤2：调用库存服务，扣减商品库存</span></span><br><span class="line">        inventoryService.reducestock(goodsskuId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Feign在接口中加入了很多注解，将库存服务提供的具体服务定义成接口方法，直接在service层进行引用。开发人员进行简单的配置就能更聚焦业务功能的编码，服务请求过程中的建立连接、构造请求、发起请求、获取回调、解析响应等工作，都被组件所隐藏了。服务间的调用就像单体服务编码时，不同service的注入一样方便。</p><p>而它的底层实现，最关键的机制就是<strong>动态代理</strong>。</p><ul><li>首先，如果你对某个接口定义了 <code>@FeignClient</code>注解，Feign就会针对这个接口创建一个动态代理</li><li>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是重中之重</li><li>Feign的动态代理会根据你在接口上的 <code>@RequestMapping</code>等注解，来动态构造出你要请求的服务的地址</li><li>最后针对这个地址，发起请求、解析响应</li></ul><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675958898063.png" alt="1675958898063"></p><h2 id="Ribbon-负载均衡组件"><a href="#Ribbon-负载均衡组件" class="headerlink" title="Ribbon 负载均衡组件"></a>Ribbon 负载均衡组件</h2><p>进入容器化时代，服务使用集群方式进行部署，假如库存服务部署在多个节点上，那么订单服务又该 <code>如何判断请求那个节点的服务呢?</code></p><ul><li>192.168.2.169:9000</li><li>192.168.2.168:9000</li><li>192.168.2.167:9000</li><li>192.168.2.166:9000</li></ul><p>Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，默认使用轮询算法，均匀的把请求分发到各个机器上。而且<strong>Ribbon是可以和Feign以及Eureka紧密协作来完成工作的</strong>，具体如下</p><ul><li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务的部署部署信息</li><li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器(节点)</li><li>Feign就会针对这台机器，构造并发起请求。</li></ul><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675960649326.png" alt="1675960649326"></p><h2 id="Hystrix-熔断降级"><a href="#Hystrix-熔断降级" class="headerlink" title="Hystrix 熔断降级"></a>Hystrix 熔断降级</h2><p>在微服务架构里，一个系统会有很多的服务。以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。这将导致的问题<strong>服务雪崩</strong>。</p><ol><li>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有能力处理后续的请求。</li><li>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</li></ol><p>但是思考一下，合理的场景应该是，<code>即使积分服务挂了，订单服务也可以不用挂掉！</code></p><ul><li>我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了。积分不是一个必要的环节</li><li>即使积分服务挂了，大不了等他恢复之后，慢慢恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</li></ul><p>那么这类问题的解决方案，就是Hystrix。<strong>Hystrix是隔离、熔断以及降级的一个框架</strong>，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p><p>举个栗子：现在很不幸，积分服务挂了，会咋样？</p><p>首先会导致订单服务里的那个用来调用积分服务的线程都卡死不能工作了！但是由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p><p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！</strong>所以我们直接对积分服务熔断的请求加入一个限制策略，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！</p><p>那人家又说，兄弟，<strong>积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？</strong>没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。</p><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675962025857.png" alt="1675962025857"></p><h2 id="Zuul-网关"><a href="#Zuul-网关" class="headerlink" title="Zuul 网关"></a>Zuul 网关</h2><p>Zuul，也就是微服务网关。这个组件是负责网络路由的。</p><p>假设你后台部署了几百个服务，前端要请求一下库存服务，难道需要记着这服务的名字叫做inventory-service？部署在192.168.2.169 192.168.2.168 等多少台机器上？大量的服务地址信息，任谁也记不住。</p><p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。Zuul可以作为单个组件，也可以配合Eureka进行转发(不同的配置规则)。</p><p>而且有一个网关之后，还有很多好处，比如可以做统一的限流、认证授权、降级，等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/myblog/2020/01/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Spring%20Cloud/SpringColud%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90/1675960805138.png" alt="1675960805138"></p><hr><blockquote><p>参考链接<br><a href="https://blog.csdn.net/qq_42046105/article/details/83793787">https://blog.csdn.net/qq_42046105/article/details/83793787</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/myblog/2019/11/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/myblog/2019/11/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>设计模式主要分为创建型、结构性、行为型三大类。创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题</p><p><img src="/myblog/2019/11/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/1675181142337.jpg" alt="1675181142337"></p><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC 容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><p>除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式包括简单工厂、工厂方法、抽象工厂这 3 种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过 new 来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面 4 个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>工厂模式一个非常经典的应用场景：依赖注入框架，比如 Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI 框架已经成为了我们平时开发的必备框架.</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li><li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li><li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。通常深拷贝是比较稳妥的做法,除非操作非常耗时,且共享数据不会被篡改时,推荐使用浅拷贝,否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这 5 种场景：</p><ul><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口适配</li><li>不同格式的数据</li></ul><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>行为型模式比较多，有 11 种，它们分别是：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成 EventBus 框架来达到这样的效果。EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><p>除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如 JdbcTemplate 就是用了回调。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</p><p>在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有 3 个优势：</p><ul><li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li><li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li><li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li></ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到 Double Disptach。如果某种语言支持 Double Dispatch，那就不需要访问者模式了。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h3 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h3><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p><blockquote><p>参考链接<br> <a href="https://refactoringguru.cn/">https://refactoringguru.cn/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令手册</title>
      <link href="/myblog/2019/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/myblog/2019/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table><h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核/OS/CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat /proc/version</td><td>查看linux版本信息</td></tr><tr><td>cat /proc/cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat /proc/interrupts</td><td>查看中断</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal /proc/meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree /proc/meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu/内存/进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写/cpu使⽤情况</td></tr><tr><td>查看io读写/cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh /dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * | sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount /dev/hda2 /mnt/hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso /mnt/cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v /dev/sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v /mnt/mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km /mnt/hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table><h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr></tbody></table><h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP/UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0/0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0/16’</td></tr><tr><td>route del 0/0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com/">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef | grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig –list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table><h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ../..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名/移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir/* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件/⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件/⽬录的物理链接</td></tr><tr><td>find / -name file1</td><td>从跟⽬录开始搜索⽂件/⽬录</td></tr><tr><td>find / -user user1</td><td>搜索⽤户user1的⽂件/⽬录</td></tr><tr><td>find /dir -name *.bin</td><td>在⽬录/dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件/可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table><h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f /log/msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s/s1/s2/g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘/^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘/ *#/d; /^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘/s1/p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s/ *$//‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s/s1//g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table><h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C /dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table><h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q –whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q –whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q –changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh –test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh –nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table><h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install –downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table><h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装/更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table><h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装/升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(JVM - 二)详解class的加载过程</title>
      <link href="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="详解class的加载过程"><a href="#详解class的加载过程" class="headerlink" title="详解class的加载过程"></a>详解class的加载过程</h1><h2 id="一、Java从编码到执行"><a href="#一、Java从编码到执行" class="headerlink" title="一、Java从编码到执行"></a>一、Java从编码到执行</h2><p>首先我们来看一下Java是如何从编码到执行的呢？ 我们有一个x.java文件通过执行javac命令可以变成x.class文件，当我们调用Java命令的时候class文件会被装载到内存中，这个过程叫做classloader。一般情况下我们自己写代码的时候会用到Java的类库，所以在加载的时候也会把Java类库相关的类也加载到内存中。装载完成之后会调用字节码解释器和JIT即时编译器来进行解释和编译，编译完之后由执行引擎开始执行，执行引擎下面对应的就是操作系统硬件了。下图是大体的流程：</p><span id="more"></span><p><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-05-32.png"></p><p>Java叫做跨平台的语言，JVM可以称之为跨语言的平台；</p><!--more--><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>1.解释器： bytecode intepreter</p><p>2.jit：just in-time compiler</p><p>3.混合模式：</p><p>混合使用解释器+热点代码编译 进行组合，起始阶段采用解释执行<br>热点代码检测 -多次被调用的代码 - 多次被调用的循环 -进行本地编译<br>-Xmixd :默认为混合模式，启动速度较快，对热点代码实行检测和编译；<br>-Xint:使用纯解释模式，启动很快，执行稍慢 ；<br>-Xcomp:  使用纯编译模式，执行很快，启动稍慢。</p><p>有个问题:java是解释执行还是编译执行？</p><blockquote><p>答：解释和编译是可以混合的，特别常用的代码或者是代码用到的次数特别多的时候，会把一个即时编译做成本地编译，这样会很大程度上的提高效率。</p></blockquote><p>Java虚拟机是如何做到这么多语言都可以在上面运行，关键在于class文件，任何语言只要能编译成class文件，并且符合class文件的规范你就可以放在Java虚拟机上去运行。</p><h2 id="二、详解class文件的加载过程"><a href="#二、详解class文件的加载过程" class="headerlink" title="二、详解class文件的加载过程"></a>二、详解class文件的加载过程</h2><p>接下来主要讲的是一个class文件是怎么从硬盘上到内存中，并开始执行的。</p><p>类加载主要有三个过程：loading 、linking 、initializing；其中linking又分为三个步骤：verification 、preparation 、resolution；<br><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-09-35.png"></p><p>1、首先Loading是什么意思呢？是把一个class文件load到内存中去；</p><p>2、接下来是Linking分为了三小步：</p><ul><li>verification  是用来校验加载进来的class文件是否符合class文件标准，如果不符合直接就会被classloader直接拒绝；</li><li>preparation  是将class文件静态变量赋默认值而不是初始值，例如static int i =8；这个步骤并不是将i赋值为8，而是赋值为默认值0；</li><li>resolution  是把class文件常量池中用到的符号引用转换成直接内存地址，可以访问到的内容；<br>3、initializing  称为初始化，静态变量在这个时候才会被赋值为初始值；</li></ul><h2 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h2><h3 id="双亲委派机制概述"><a href="#双亲委派机制概述" class="headerlink" title="双亲委派机制概述"></a>双亲委派机制概述</h3><p>类加载器的加载过程是分成不同的层次来加载的，不同的类加载器来加载不同的class文件，  Bootstrap &gt;Extension&gt;Application&gt;Custom(自定义类加载器)，其遵循的加载策略即是双亲委派机制。</p><p>下面为类加载过程(双亲委派)的简化图：<br><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200629165000263-2051250630.png"></p><p>1、第一个类加载器的层次为：Bootstrap 称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库。</p><p>2、第二个类加载器的层次为：Extension 是用来加载扩展类的，主要负责加载Java的扩展类库,默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar包。</p><p>3、第三个类加载器的层次为：Application 又称为系统类加载器,负责在JVM启动时,加载来自在命令java中的classpath或者java.class.path系统属性或者CLASSPATH操作系统属性所指定的JAR类包和类路径。</p><p>4、第三个类加载器的层次为：CustomClassLoader(自定义加载器)  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Bootstrap加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> property.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Ext加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property1</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> property1.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------App加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property2</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> property2.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/**输出结果只截取了部分*/</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\resources.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\rt.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\sunrsasign.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jsse.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jce.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jfr.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\classes</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext</span></span><br><span class="line">        <span class="comment">//C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\deploy.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\access-bridge-64.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\cldrdata.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\dnsns.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jaccess.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jfxrt.jar</span></span><br></pre></td></tr></table></figure><p>下图为类加载的一个全过程：<br><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200630084433768-1150504306.png"><br>用比较通俗的话来解释这个过程，当有一个类需要被加载时，首先要判断这个类是否已经被加载到内存中。判断加载与否的过程是自下而上的，如果class类有自己定义的类加载器，会先到CustomClassLoader 管理的cache（缓存）中去找是否已经加载，若已加载直接返回结果，否则到上层加载器ApplicationClassLoader的cache中查找，如果已经存在直接返回，如果不存在，到Extension中查找，存在直接返回，不存在继续向父加载器中寻找直到Bootstrap顶层，如果依然没找到，那就是没有加载器加载过这个类。需要委派对应的加载器来加载，上层加载器先看看这个类是否在自己的加载范围内，如果是直接加载返回结果，若不是继续向下委派，以此类推直到最下级，如果最终也没能加载，就会直接抛异常 ClassNotFoundException，这就是双亲委派模式的流程。</p><h3 id="理解双亲委派模式"><a href="#理解双亲委派模式" class="headerlink" title="理解双亲委派模式"></a>理解双亲委派模式</h3><p>1、父加载器：不是类加载器的加载器，也不是类加载器的父类加载器（此处意思是没有父类与子类之间的继承关系）。<br>通常会将 BootstrapClassLoader 称为 ExtensionClassLoader 的父加载器；<br>ExtensionClassLoader 称为 ApplicationClassLoader 的父加载器；<br>ApplicationClassLoader 称为 CustomClassLoader 的父加载器；<br>但这个父子关系并不代表着JAVA语法中的继承，而更形象的只是一种语义上的关联，实际就是ClassLoader的类中有一个成员变量parent指向了其关联的ClassLoader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证了父加载器不是加载器的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentAndChild</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//AppClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null  这里AppClassLoader的加载器不是ExtClassLoader  而是Bootstrap</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">appclassLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getClass().getClassLoader();</span><br><span class="line">        System.out.println(appclassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ExtClassLoader   AppClassLoader的父加载器是ExtClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**输出结果*/</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@23fc625e</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException at com.example.demo.classloader.ParentAndChild.main(ParentAndChild.java:22)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、双亲委派：其工作原理的是，如果一个类加载器收到了类加载请求，并不会直接去加载，而是自下而上的向顶层类加载器查找是否已经被加载了，如果被加载就不用进行加载，如果未被加载过，则会自上而下的检查是否属于自己加载的范围，如果属于则加载，如果不属于则向下委托，直到类被加载进来才能叫做成功，如果加载不成功就会抛异常classnotfoundexeption,这就叫做双亲委派。</p><p>3、为什么要搞双亲委派模式？</p><p>主要是为了安全，这里可以使用反证法，如果任何类加载器都可以把class加载到内存中，我们就可以自定义类加载器来加载Java.lang.string。在打包时可以把密码存储为String对象，偷偷摸摸的把密码发送到自己的邮箱，这样会造成安全问题。</p><h2 id="四、自定义类加载器"><a href="#四、自定义类加载器" class="headerlink" title="四、自定义类加载器"></a>四、自定义类加载器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderByHand</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = ClassLoaderByHand.class.getClassLoader().</span><br><span class="line">                loadClass(<span class="string">&quot;com.example.demo.threaddemo.juc_002.Account&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 输出结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//com.example.demo.threaddemo.juc_002.Account</span></span><br></pre></td></tr></table></figure><p>代码运行结果可以看出，若要加载一个类你只要调用classLoader中的 loadClass()方法就能把这个类加载到内存中，加载完成之后会给你返回一个Class类的对象。</p><p>在硬盘上找到这个类的源码，把它load到内存，与此同时生成一个Class对象，上述的小程序是通过 ClassLoaderByHand 找到他的加载器AppClassLoader 然后调用它的loadClass()方法，让它帮我们把 Account类加载进来，返回一个clazz对象，使用clazz.getName()方法正常返回Account类。</p><blockquote><p>什么时候我们需要自己定义去加载一个类？</p><ul><li>热部署时就是先把之前加载的类给干掉 ，然后使用的自定义类加载器来进行重新加载</li><li>spring的动态代理，一个新的class 当需要的时候就会把它load到内存中</li></ul></blockquote><h3 id="ClassLoader的源码分析"><a href="#ClassLoader的源码分析" class="headerlink" title="ClassLoader的源码分析"></a>ClassLoader的源码分析</h3><p>我们还是来看一下ClassLoader的源码，加载过程最主要的还是ClassLoader中的loaderClass()方法：</p><p> 结合上面给的类加载过程的图解一起看会更容易一些；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在加载之前先调用findLoadedClass()方法查看是否已经加载过此类</span></span><br><span class="line"><span class="comment">             * 若加载过 返回该对象</span></span><br><span class="line"><span class="comment">             * 如果未加载则返回null 进行下一步</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//判断有无父加载器 如果不为空说明还未到顶层Bootstrap递归调用loadClass()</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果没有父加载器说明调用的加载器为Bootstrap Class Loader, 在此加载器内存中查找是否已经加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若以上的操作都没成功加载此类</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//调用自己的findClass()</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义classLoader"><a href="#自定义classLoader" class="headerlink" title="自定义classLoader"></a>自定义classLoader</h3><p>1.继承ClassLoader抽象类 extends ClassLoader<br>2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int off, int len)<br>3.加密（可以对class字节码文件进行加密处理，可选）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.FileUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.log.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 继承ClassLoader抽象类 extends ClassLoader</span></span><br><span class="line"><span class="comment"> * 2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int</span></span><br><span class="line"><span class="comment"> * 3.加密（可以对class字节码文件进行加密处理，可选）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0B10110110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 findClass 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.myclass&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != <span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b ^ seed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//defineClass最终将二进制流转换为Class类对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对旧class文件的处理,可选，此方法中使用按位取反</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classFileBasePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classPackagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encFile</span><span class="params">(String classFileBasePath, String classPackagePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePahtWithoutSuffix</span> <span class="operator">=</span> classFileBasePath.concat(<span class="string">&quot;/&quot;</span>).concat(classPackagePath.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//旧的class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">oldFis1</span> <span class="operator">=</span> FileUtil.getInputStream(oldClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.myclass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">newFos</span> <span class="operator">=</span> FileUtil.getOutputStream(newClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (oldFis1.read() != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//按位取反</span></span><br><span class="line">            newFos.write(b ^ seed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldFis1.close();</span><br><span class="line">        newFos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        encFile(classFileBasePath, classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> (Hello) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        h.sayHello();</span><br><span class="line"></span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l是由&#123;&#125;加载而来&quot;</span>, l.getClass().getClassLoader());</span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l的父加载器是&#123;&#125;&quot;</span>, l.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、破坏双亲委派机制"><a href="#五、破坏双亲委派机制" class="headerlink" title="五、破坏双亲委派机制"></a>五、破坏双亲委派机制</h2><p>1.如何破坏双亲委派模型？</p><p>通过重写loadClass()方法。</p><p>2.什么时候破坏过双亲委派模型？</p><blockquote><ul><li>JDK1.2之前，自定义classLoader都必须重写loadClass ()方法。（缺陷）</li><li>ThreadContextClassLoader可以实现基础类调用实现类的代码</li><li>热启动/热部署  tomcat 都有自己的模块指定classLoader（可以加载同一类库的不同版本）</li></ul></blockquote><p>当下也就只能对自定义的class实现打破双亲委派的策略来加载</p><p>破坏双亲委派模型的简单实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重新loadClass方法来打破双亲委派机制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li on 2020/9/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.tiny.security.util.Hello cannot be cast to com.tiny.security.util.Hello</span></span><br><span class="line">        <span class="comment">//Hello h1old = (Hello) clazz.newInstance();</span></span><br><span class="line">        <span class="comment">//h1old.sayHello();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h1</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h1.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在此处断点后，修改hello方法中的输出内容，并重新编译生成新的class</span></span><br><span class="line"><span class="comment">            观察两次输出的内容,可以判定class是否被重新加载了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> l2.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h2</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz2.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h2.sayHello();</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>原文/参考链接<br>calss 加载过程: <a href="https://www.cnblogs.com/dongl961230/p/13212080.html">https://www.cnblogs.com/dongl961230/p/13212080.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JVM调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区域截图异常问题排查</title>
      <link href="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>上个月开发了一个业务功能，整体的流程是通过配置的定时任务，在触发时刻将使用谷歌的爬虫工具selenium在后台通过用户的身份登录公司的报表系统门户中，查看配置的某些报表，进行截图后将图片信息结合配置的内容排版，通过邮件发送到用户邮箱中。就是这样一个简单的需求，但缺因为自己的不细心不自信，加上连续遇上了两个外部jar包的bug，耗费了一整天的时间还加班到凌晨。</p><span id="more"></span><p>区域截图的处理示意图<br><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595324550060.png"></p><ol><li>打开报表时，先定位div元素的起点坐标和元素宽高，并截取全屏的图片</li><li>使用区域截图的方法结合第1步记录的信息，只截取报表展示区域的图片内容</li></ol><h2 id="异常描述"><a href="#异常描述" class="headerlink" title="异常描述"></a>异常描述</h2><p>原本简单的截图需求，在多次使用截图方法后，输出的截图文件却始终不合规范。</p><h3 id="代码贴图"><a href="#代码贴图" class="headerlink" title="代码贴图"></a>代码贴图</h3><ol><li>通过谷歌浏览器驱动进行截图的代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取多张管理画布的截图页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName  登录用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> passWord  用户密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reportIdList  需要查看的管理画布报表的id列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, File&gt; <span class="title function_">dataexplorScreenShotMap</span><span class="params">(String userName, String passWord, List&lt;String&gt; reportIdList)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置驱动地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">driverPath</span> <span class="operator">=</span> getChromeDriverPathByOs();</span><br><span class="line"></span><br><span class="line">    HtmlScreenshotSettingParam.settingParamInit();</span><br><span class="line"></span><br><span class="line">    System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, driverPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">ChromeOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeOptions</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是要执行的命令，不打开浏览器窗口的方式，如需修改截图页面的尺寸，修改--window-size的参数即可</span></span><br><span class="line">    options.addArguments(</span><br><span class="line">            <span class="string">&quot;--headless&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--disable-gpu&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--ignore-certificate-errors&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定模拟打开浏览器的窗口的宽高</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;--window-size=1440,1200&quot;</span>;</span><br><span class="line"></span><br><span class="line">    options.addArguments(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 先进行登录</span></span><br><span class="line">    <span class="type">WebDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeDriver</span>(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问页面</span></span><br><span class="line">    driver.get(HtmlScreenshotSettingParam.DAP_LOGIN_PAGE_URL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//账号密码，按钮  ，直接模拟登录</span></span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;login_name&quot;</span>)).sendKeys(userName);</span><br><span class="line"></span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;user_cipher&quot;</span>)).sendKeys(passWord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟点击登录按钮</span></span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;btnSubmit&quot;</span>)).click();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定等待时间供连接访问</span></span><br><span class="line">    Thread.sleep(HtmlScreenshotSettingParam.PAGE_LOADING_WAITING_TIME);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; ImageMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, File&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String canvasReportId : reportIdList) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结合报表的id，构造报表的展示地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reportUrl</span> <span class="operator">=</span> HtmlScreenshotSettingParam.CANVAS_REPORT_MODEL_URL.replace(<span class="string">&quot;&#123;reportId&#125;&quot;</span>, canvasReportId);</span><br><span class="line"></span><br><span class="line">        driver.get(reportUrl);</span><br><span class="line"></span><br><span class="line">        driver.navigate().refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.登录后访问报表地址</span></span><br><span class="line">        logger.info(<span class="string">&quot;当前展示的页签名称:&quot;</span> + driver.getTitle());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(HtmlScreenshotSettingParam.PAGE_LOADING_WAITING_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到截图的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">screenshotFile</span> <span class="operator">=</span> ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换格式</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">screenshotFormatFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>( screenshotFile.getPath().replace(<span class="string">&quot;.png&quot;</span>, HtmlScreenshotSettingParam.ImageFormat));</span><br><span class="line"></span><br><span class="line">        ImgUtil.convert(screenshotFile, screenshotFormatFile);</span><br><span class="line"></span><br><span class="line">        screenshotFile = screenshotFormatFile;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图,只获取管理画布内容</span></span><br><span class="line">        screenshotFile = regionalScreenshots(driver, screenshotFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((screenshotFile != <span class="literal">null</span>) &amp;&amp; screenshotFile.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            ImageMap.put(canvasReportId, screenshotFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver.quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ImageMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>区域截图的处理逻辑方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile 完整的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;进入画布的区域截图方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                + screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制完整的图片文件</span></span><br><span class="line">        FileUtils.copyFile(screenshotFile, cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找画布div节点</span></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//矩形图像对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x、y表示加上当前frame的左边距,上边距</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">dest</span> <span class="operator">=</span> image.getSubimage(point.x, point.y, rect.width, rect.height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写出截图文件</span></span><br><span class="line">        ImageIO.write(dest, <span class="string">&quot;png&quot;</span>, cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + cacheShotPic.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheShotPic;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常规登录页面获取管理画布</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataexplorScreenShotMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;cw&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">passWord</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String[] reportIdArr = &#123;&quot;24160932063991478208&quot;, &quot;50582076917040768340&quot;, &quot;50570813594059717529&quot;&#125;;</span></span><br><span class="line">    String[] reportIdArr = &#123;<span class="string">&quot;243945938171462886942&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; reportIdList = Arrays.asList(reportIdArr);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; imageMap = HtmlScreenshotUtil.dataexplorScreenShotMap( userName, passWord, reportIdList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;调用工具类后,取得截图文件:&quot;</span> + imageMap.keySet().size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key : imageMap.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">imageFile</span> <span class="operator">=</span> imageMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/&quot;</span> + key + <span class="string">&quot;_&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">            FileUtil.copy(imageFile, <span class="keyword">new</span> <span class="title class_">File</span>(pathname));</span><br><span class="line"></span><br><span class="line">            System.out.println(pathname);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>截取的图片文件预览</li></ol><ul><li>完整截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot4011539626072935834_complete_20200721205449.jpg"></li><li>区域截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/243945938171462886942_1595335555972.png"></li></ul><p>这显然不是我们想要的结果,  但是本人从代码层面没有发现明显的异常。也是由于工作中对图片的处理用的比较少，不太确定代码的正确性。</p><h2 id="试错过程"><a href="#试错过程" class="headerlink" title="试错过程"></a>试错过程</h2><p>由于没能找到当前代码中的异常，于是换了其他的处理逻辑。想起此前领导案例的一个”优秀的”第三方工具包hutool，查看其文档后，发现其中也有图片处理的方法，maven引用也很便捷。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-captcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hutool 中包含两个类似的图片工具类</p><ul><li><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片工具-ImgUtil">图片工具-ImgUtil</a></li><li><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片编辑器-Img">图片编辑器-Img</a></li></ul><p>阅读相关的文档并，我选择了图片编辑器中的图像切割，因为后续也会使用到图片的缩放，链式调用使得代码很简洁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"><span class="comment">//矩形裁剪</span></span><br><span class="line">    .cut(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height))</span><br><span class="line"><span class="comment">//缩放</span></span><br><span class="line">    .scale(<span class="number">900</span>,<span class="number">600</span>)</span><br><span class="line"><span class="comment">//写出</span></span><br><span class="line">    .write(FileUtil.file(screenshotFile));</span><br></pre></td></tr></table></figure><h3 id="使用hutool-图片编辑器裁剪图片"><a href="#使用hutool-图片编辑器裁剪图片" class="headerlink" title="使用hutool-图片编辑器裁剪图片"></a>使用hutool-图片编辑器裁剪图片</h3><ol><li>修改后的区域截图方法代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容 - 使用hutool 的图片编辑器进行裁剪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                +screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的全屏文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheCompletePic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"></span><br><span class="line">                .cut(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height))</span><br><span class="line"></span><br><span class="line">                .scale(HtmlScreenshotSettingParam.canvasScaleWidth, HtmlScreenshotSettingParam.canvasScaleHighth)</span><br><span class="line"></span><br><span class="line">                .write(FileUtil.file(screenshotFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的区域截图文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheShotPic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试方法运行图效果</li></ol><ul><li><p>完整截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot263478830502424703_complete_20200722100018.jpg"></p></li><li><p>区域截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot263478830502424703_shot_20200722100018.jpg"><br>同样，截图的区域不是预期的效果。而且对于相同的矩形起点和宽高，为何两种方案截图出来的效果都不一致？真叫人头大。</p></li></ul><h3 id="穷举测试"><a href="#穷举测试" class="headerlink" title="穷举测试"></a>穷举测试</h3><p>我开始破罐子破摔的方式，手动调整截图的起点和范围。试想的方案是，使用之前存下来的全屏的图片文件,  本地编写矩形区域的真实宽高，重复尝试着确认起始点的坐标，观察截图文件的内容。<br>此时已经变更截图方法为 hutool-图片编辑器 的截图方法，故以此编写了测试类</p><ol><li>正常宽高测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/画布div起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, width, highth);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle1)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/原点起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试效果图</p><ul><li><p>以画布坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E7%94%BB%E5%B8%83div%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li><li><p>以原点坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8E%9F%E7%82%B9%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li></ul><p>几张图片的尺寸是一致的，但是实际截取的范围都比画布的尺寸更小。甚至原点都不在图片文件的左上顶点。于是我决定把宽高的范围手动扩大，观察效果。</p><ol start="2"><li>设定双倍宽高<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutDoubleTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width * <span class="number">2</span>, highth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/双倍画布div起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, width * <span class="number">2</span>, highth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle1)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/双倍原点起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试效果图</li></ol><ul><li><p>以画布坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E7%94%BB%E5%B8%83div%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li><li><p>以原点坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E5%8E%9F%E7%82%B9%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li></ul><p>看到第二张图的效果，除了顶部的灰色条，几乎都完美的解决了我的问题。再次尝试修改坐标位置，截取得到了只包含画布的微调截图范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line"><span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, y, width * <span class="number">2</span>, highth * <span class="number">2</span> - y);</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E5%8E%9F%E7%82%B9%E5%BE%AE%E8%B0%83%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p><p>由于需要赶进度，就按照这种改动设定了宽高和坐标轴，对代码进行了提交。此时对截取的范围的选择和理解，依旧和java的截图矩形类的定义不一致 ，逻辑上其实是不正确的。<br>而代码提交后，交付到运维同事，他本地拉取代码部署运行后。通过邮件接收到的截图内容，简直堪称离谱。和我本地的测试效果完全不一样。<br><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595396629702.png"></p><h3 id="补全日志信息"><a href="#补全日志信息" class="headerlink" title="补全日志信息"></a>补全日志信息</h3><p>我确定代码是一致的，但是运行效果的差异，这让我意识到也许和操作系统环境有关。我本地使用mac系统，同时用的windows机器，部署上线的又是linux系统中。由于最初编码的时候，实际并没有上述代码块中那么多详细的日志，为了对比具体的执行差异，才在方法中补全了足够详细的日志记录。 也翻出了我家里的老伙计，辅助做印证测试。</p><p>mac上执行截图的测试方法,从控制台看到本次执行过程打印的日志</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">42</span>,<span class="number">402</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">252</span> - 当前展示的页签名称:<span class="number">2020</span>进阶趋势 › page1</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">358</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">613</span> - 进入画布的区域截图方法</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">374</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">643</span> - 留存当前图片的全屏内容,存放位置 /<span class="symbol">Users</span>/buqiugouda/.oldsemf/chromedriver/screenshot/screenshot5254156389223784299_complete_20200722135053.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">460</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">647</span> - 当前全屏文件的宽度:<span class="number">2880</span> 高度:<span class="number">2400</span></span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">478</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">654</span> - 当前全屏文件包含了画布的区域,起点坐标(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">489</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">661</span> - 当前画布内容的宽度:<span class="number">840</span> 高度:<span class="number">1190</span></span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">54</span>,<span class="number">045</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">675</span> - 留存当前图片的区域截图内容,存放位置 /<span class="symbol">Users</span>/buqiugouda/.oldsemf/chromedriver/screenshot/screenshot5254156389223784299_shot_20200722135053.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">54</span>,<span class="number">054</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">679</span> - 当前区域截图文件经过指定尺寸缩放后的宽度:<span class="number">800</span> 高度:<span class="number">900</span></span><br></pre></td></tr></table></figure><p>windows上执行截图测试方法，从控制台看到本次执行过程打印的日志</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">04</span>,<span class="number">778</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">252</span> - 当前展示的页签名称:<span class="number">2020</span>进阶趋势 › page1</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">265</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">613</span> - 进入画布的区域截图方法</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">272</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">643</span> - 留存当前图片的全屏内容,存放位置 <span class="symbol">D</span>:\\oldsemf\chromedriver\screenshot\screenshot2057483932069022115_complete_20200722135711.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">355</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">647</span> - 当前全屏文件的宽度:<span class="number">1440</span> 高度:<span class="number">1200</span></span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">373</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">654</span> - 当前全屏文件包含了画布的区域,起点坐标(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">385</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">661</span> - 当前画布内容的宽度:<span class="number">840</span> 高度:<span class="number">1190</span></span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">901</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">675</span> - 留存当前图片的区域截图内容,存放位置 <span class="symbol">D</span>:\\oldsemf\chromedriver\screenshot\screenshot2057483932069022115_shot_20200722135711.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">908</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">679</span> - 当前区域截图文件经过指定尺寸缩放后的宽度:<span class="number">800</span> 高度:<span class="number">900</span></span><br></pre></td></tr></table></figure><p>重点落在首次截取的全屏图片文件的宽高上，mac上截得文件的宽高居然是windows上的两倍。而我在代码中调用谷歌驱动时，分明指定了模拟浏览器打开时，窗口的宽高为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定模拟打开浏览器的窗口的宽高</span></span><br><span class="line"><span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;--window-size=1440,1200&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>这就说明mac截图下来的文件，自行将图片宽高扩大了一倍！当然这个bug，谷歌浏览器驱动包 selenium-chrome-driver 依赖jar包中的截图方法，与当前mac 系统的版本号，我安装的浏览器版本 更具体的对应关系是否有关就不得而知。</strong></p><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><p>新编写一个测试类，将历史测试数据中的完整截图先等比缩放以后再进行矩形区域的截图。<br>使用hutool 图片编辑器提供的缩放裁剪链式调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍 - 再进行截图</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).cut(rectangle).write(cacheShotPic);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图<br>    <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595405941568.png"></p><p>(几近崩快，居然还是没能正确地截取！！！)</p><h3 id="对比测试"><a href="#对比测试" class="headerlink" title="对比测试"></a>对比测试</h3><p>既然出现了 selenium-chrome-driver 外部依赖的bug，完全有理由怀疑 hutool 提供的截图方法存在bug.<br>使用java的 BufferedImage 的截取方法进行截取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompleteScalePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图-等比缩放.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompleteScalePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).write(cacheCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">img</span> <span class="operator">=</span> ImageIO.read(cacheCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在缩放后的图片上指定范围来截图</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">dest</span> <span class="operator">=</span> img.getSubimage(x, y , width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    ImageIO.write(dest, <span class="string">&quot;png&quot;</span>, cacheShotPic);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图<br>    <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595406306543.png"></p><p>是的，这足以证明hutool的 <a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片编辑器-Img">图片编辑器-Img</a> 中提供的.cut() 的矩形截图方法是存在bug的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自此已经明确找出两处bug和他们的影响，通过windows机器上的对比可确定解决方案。mac系统上截取的全屏图片由于被拉伸，所以在区域截图前应当先缩放，在用指定的矩形范围和坐标进行截图。最终验证测试了hutool的另一个图片处理工具<br><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片工具-ImgUtil">图片工具-ImgUtil</a> ，发现其矩形截图方法.cut()是同BufferedImage.getSubimage()原理一致的。<br>使用hutool的图片工具ImgUtil编写的测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).write(cacheShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//截取</span></span><br><span class="line">    ImgUtil.cut(cacheCompletePic, cacheShotPic, rectangle);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图</p><p><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595407306025.png"></p><p>变更区域截图的处理逻辑方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots0</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;进入画布的区域截图方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                +screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的全屏文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheCompletePic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//浏览器窗口的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowWidth</span> <span class="operator">=</span> driver.manage().window().getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//浏览器窗口的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowHeight</span> <span class="operator">=</span> driver.manage().window().getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把全屏文件的尺寸缩放到与设定窗口的宽高一致，调整图片尺寸后续再截图</span></span><br><span class="line">        Img.from(screenshotFile)</span><br><span class="line">                .scale(windowWidth, windowHeight)</span><br><span class="line">                .write(screenshotFile);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//截图</span></span><br><span class="line">        ImgUtil.cut(screenshotFile, screenshotFile, <span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"></span><br><span class="line">                .scale(HtmlScreenshotSettingParam.canvasScaleWidth, HtmlScreenshotSettingParam.canvasScaleHighth)</span><br><span class="line"></span><br><span class="line">                .write(FileUtil.file(screenshotFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的区域截图文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheShotPic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ol><li>对图片处理的原生方法使用太少，未能根据截取效果第一时间判断，自己是否对矩形范围的坐标和宽高设定有误。</li><li>外部驱动的使用有时候因为技术方案或者业务需求无法变动，但都需要做足够详细的技术验证和测试工作。否则开发工程中的意外试错，将会影响工作效率和进度</li><li>外部的工具包虽然是大牛编写的，但也并不能预知所有的情况。对工具的使用，并不该只停在”拿来主义”，看看它的源码，也能对自己有所帮助。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot-静态页面无法加载</title>
      <link href="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/"/>
      <url>/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前段时间帮项目上的同事改造一个springboot项目，后端使用springboot框架开发，前端使用node.js编译后将静态资源放到后端自行新增的webapp目录下,  又套用了web.xml等一系列配置将项目改造成了web项目,最终以war包形式进行发布。  </p><span id="more"></span><p>本人的任务是为此项目接入统一认证的平台，使用了已经验证过的拦截器，来实现登录的会话验证。强迫症让我又将项目结构调整为普通的springboot的结构。</p><p>在添加完拦截器之后，后端接口测试基本都一次过,拦截器的逻辑也都符合预期。但是加入静态资源后，进入主页却始终无法引用到相关的静态资源。</p><p><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%BC%82%E5%B8%B8%E4%B8%BB%E9%A1%B50.png"></p><p>而所有单独请求静态资源的url都返回404，查看idea 发现以下日志记录<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%AA%E8%AF%86%E5%88%AB7a3a0a8a.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p> 静态文件结构:<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84f978d5f6.png"></p><p>前端页面的解析使用sprinboot提供的thymeleaf,并在配置文件中完成配置。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/thymeleaf%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%901e5a6d02.png"></p><h2 id="解决问题的流程"><a href="#解决问题的流程" class="headerlink" title="解决问题的流程"></a>解决问题的流程</h2><h3 id="排查资源编译路径"><a href="#排查资源编译路径" class="headerlink" title="排查资源编译路径"></a>排查资源编译路径</h3><p>最初只是注意到页面的空白，以及idea的日志记录，百度后就认定为静态资源无法读取。<br>重新maven编译后，确认target的同目录结构下，是存在相关静态资源的，于是排除了编译问题。</p><h3 id="排查springboot关于静态文件的读取配置"><a href="#排查springboot关于静态文件的读取配置" class="headerlink" title="排查springboot关于静态文件的读取配置"></a>排查springboot关于静态文件的读取配置</h3><p>由于接触的项目跨度比较大，从jsp之后，经手的项目都是前后端分离的。所以去网络上查找也学习了关于静态文件的配置方法。</p><p>参考此文档后 <a href="https://www.jianshu.com/p/a9e6edd46e98">https://www.jianshu.com/p/a9e6edd46e98</a> ,算是理清了静态文件资源的读取规则。<br>于是满怀信心后添加配置<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/springboot%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AEa206d7fd.png"></p><p>但页面依旧没有任何变化。冷静查看 spring.resources.static-locations 指向的默认配置类<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE7a27e960.png"><br>而我的项目中，存放静态资源的位置，本来就位于其中,加上sprongboot默认的静态资源匹配规则就是 /**, 其实我这个项目压根就用不着额外配置</p><p>继续翻阅文章是，注意到springboot早起的版本，对于静态资源的放行，不是直接配置而是放到了拦截器中进行处理。正好我做会话认证的功能也是写在自定义拦截器的实现类中,于是仿写了相关配置在拦截器中进行静态资源的匹配和处理规则。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BBe33b5431.png"></p><p>再次打开项目，进入主页时，异常居然就解决了。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%BB%E9%A1%B5dbf500e7.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>再次审阅我的自定义”拦截器”<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%94%AF%E4%B8%80%E9%85%8D%E7%BD%AE%E7%B1%BB3f5855e9.png"></p><p>等等为什么这个类 是在继承 WebMvcConfigurationSupport, 我的其他项目中使用拦截器似乎有点不同。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8567273b7.png"><br>其他项目中使用的都是 WebMvcConfigurer的自定义实现类</p><p>继续搜索了相关资料后, 了解了WebMvcConfigurationSupport 和 WebMvcConfigurer 的区别和关联<br>参考链接: <a href="https://www.jianshu.com/p/c5c1503f5367">https://www.jianshu.com/p/c5c1503f5367</a></p><p>WebMvcConfigurationSupport 在整个应用程序中只会生效一个，如果用户已经实现了 WebMvcConfigurationSupport，则 DelegatingWebMvcConfiguration 将不会生效。换句话来说，WebMvcConfigurer 的所有实现类将不会生效。<br>而在Spring 中，如果类路径上不存在 WebMvcConfigurationSupport 的实例，则将会默认实现WebMvcConfigurerAdapter、DelegatingWebMvcConfiguration 来自定义mvc 配置。</p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>对于我本次改造的项目而言,静态文件的存放路径就在springboot的默认配置路径中,不要额外指定和配置。只需要修改拦截器的实现类，使用 WebMvcConfigurer 的自定义实现类来定义会话拦截器就可以了。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2>]]></content>
      
      
      <categories>
          
          <category> 工作踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 使用主题butterfly</title>
      <link href="/myblog/2019/05/23/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/myblog/2019/05/23/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="使用butterfly主题后-如何为文章添加本地的封面"><a href="#使用butterfly主题后-如何为文章添加本地的封面" class="headerlink" title="使用butterfly主题后,如何为文章添加本地的封面"></a>使用butterfly主题后,如何为文章添加本地的封面</h2><p>启用文章封面设置后, 可以在文章的头部设置cover属性,使用外连最简单</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">……</span></span><br></pre></td></tr></table></figure><p>但如果没有图床,又想设置内容,则可以尝试在项目目录下,自行放置图片,并在头部进行引用。<br>也可以在贴图文件夹中存放,但是cover地址，则需要设置成打包后查看该图片的地址<br><code>cover: ./2021/05/22/hexo配置与使用/hexo使用butterfly主题/backage.jpg</code></p>]]></content>
      
      
      <categories>
          
          <category> hexo配置使用 </category>
          
          <category> butterfly主题设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 使用配置</title>
      <link href="/myblog/2019/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/myblog/2019/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo图片不展示"><a href="#hexo图片不展示" class="headerlink" title="hexo图片不展示"></a>hexo图片不展示</h2><p>图片不展示时，观察图片src的路径是否有误。曾出现过在列表全展示时无法查看图片，点进具体博文后可展示图片的异常。</p><span id="more"></span><p>日常使用 Markdown 编写时,都会将静态资源贴到同名文件夹下,通常由文档工具(如 <code>Typora</code>、<code>VsCode</code>) 自动配置完成, .md文件与外部文件夹同级别,兼顾文档与静态文件的归类和美观。<br>形如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├ test-blog              (存放图片等静态资源的文件夹)</span><br><span class="line">|   ├ a.png</span><br><span class="line">|   └ b.png</span><br><span class="line">└ test-blog.md           (markdown文件)</span><br></pre></td></tr></table></figure><p>而在 <code>hexo</code>的设定中,外层配置文件 <code>_config.yml</code>中存在属性 <code>post_asset_folder</code>，它控制着是否携带静态资源打包到目录中，默认值是 <code>false</code>,只有设置为 <code>ture</code>, 才会将静态资源打包到html同级目录下。形如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">  └ 2019</span><br><span class="line">      └ 08</span><br><span class="line">         └ 21</span><br><span class="line">            └ test-blog</span><br><span class="line">                ├ index.html        (markdown文件被编译后生成的.html文件)</span><br><span class="line">                ├ a.png</span><br><span class="line">                └ b.png             (文件引用的静态图片,如果不更改属性post_asset_folder为true, 则编译后该目录下不会生成这些图片)</span><br><span class="line"></span><br><span class="line">(明显编译后的结构也和源文件的存放路径不相同)</span><br></pre></td></tr></table></figure><p>此时启动项目后,会发现请求静态资源时路径中出现了两次文件夹名称。 形如: <code>http://localhost:5000/2022/08/03/test-bolg/test-bolg/a.png</code> ,其中/test-blog文件夹名出现了两次，页面中查看该文章时，就无法显示图片内容。<br>而如果保持属性 <code>post_asset_folder</code>修改为 <code>false</code>, 生成文章html中,读取图片的路径是正确的(形如:<code>http://localhost:5000/2022/08/03/test-bolg/a.png</code>), 路径虽然正确,但却因为静态资源没有被编译,导致同样无法展示图片。</p><p>换个说法就是官方 希(只)望(支)你(持) 把md文件和图片放在同一级。形如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test-blog</span><br><span class="line">   ├ a.png</span><br><span class="line">   ├ b.png</span><br><span class="line">   └ test-blog.md</span><br></pre></td></tr></table></figure><p>在查找资料时,多个资料都有提到插件 <code>hexo-asset-image</code> 专门用来解决问题, 但我使用 <code>npm install hexo-asset-image --save</code> 后, 图片路径依旧存在问题。最终在一篇帖子里，找到插件不可用的原因。</p><p><strong>解决方案</strong></p><p>1.将属性 <code>post_asset_folder</code>修改为 <code>true</code></p><p>2.必须使用 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code> 安装0.0.5版本的hexo-asset-image插件。</p><p>这里解释下, 从github上访问项目’<a href="https://github.com/CodeFalling/hexo-asset-image&#39;">https://github.com/CodeFalling/hexo-asset-image&#39;</a> 时,其链接地址也做了自动转发,也就是到了新版本的 <code>hexo-asset-image</code>, 而在新版本的readme文档中,其推荐使用安装命令 <code>npm install hexo-asset-image --save</code>, 得到的是1.0.0版本，但正因为版本映射的不同，必须使用旧版本插件才能解决图片资源的问题。</p><p>(关于这一点，也许在hexo的新版本，或者插件的作者会做更新调整。当前的解决方案有一点局限性，持续观望中…)</p><p>参考地址:<a href="https://www.jianshu.com/p/db02d775aed0">https://www.jianshu.com/p/db02d775aed0</a><br><code>&lt;br&gt;</code><br><code>&lt;br&gt;</code></p><h2 id="hexo在码云上使用时的样式和图片404异常"><a href="#hexo在码云上使用时的样式和图片404异常" class="headerlink" title="hexo在码云上使用时的样式和图片404异常"></a>hexo在码云上使用时的样式和图片404异常</h2><p>hexo 博客搭桥到github 对 _config.yml 下的配置基本没有改动。但同样的配置部署到gitee后,却出现样式文件404导致显示出现很多异常。</p><p>异常内容形如<br><img src="/myblog/2019/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/350307b1.png"></p><p>百度了很多的帖子,也翻阅了gitee的API文档 <code>&lt;a href=&quot;https://gitee.com/help/articles/4136#article-header0&quot; title=&quot;码云Pages&quot;&gt;</code>码云Pages<code>&lt;/a&gt;</code><br>大致都是说由于gitee部署的page服务,使用的域名后携带了项目名称,导致样式文件和图片的相对路径不正常,本地预览博客正常,上线后会出错。 于是在 _config.yml 中进行了如下配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://buqiugouda.gitee.io/myblog</span><br><span class="line">root: /myblog</span><br></pre></td></tr></table></figure><p>hexo clean; hexo g; hexo d 重新手动部署page服务后,发现主页的样式文件已经没有问题了. 但是正文里的图片还是无法正常显示.<br><img src="/myblog/2019/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/b2f00f08.png"></p><p>得确很多帖子都是这么处理的，也有博主进行贴图,评论区表示感谢的,怎么到了我这里问题只解决了一半。于是调出控制台,发现找不到的图片引用都是重复了两次项目名 /myblog<br>public中编译得到的静态文件,其指向图片的引用也是两次 /myblog, 实际本地启动的服务,也有同样的情况,只是我误以为gitee上部署后,会通过域名映射啥的解决这个问题.</p><p>我决定只配一次项目名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://buqiugouda.gitee.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/myblog</span></span><br></pre></td></tr></table></figure><p>本地启动展示效果图<br><img src="/myblog/2019/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/8eb68b1b.png"></p><p>提交后重新部署gitee后的效果图<br><img src="/myblog/2019/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/2f880909.png"></p><p>问题解决.但的确多数的帖子和gitee的官方文档都是如此处配置的,也有评论对对第一种配置表示感谢,他们一定也解决了他们的问题,为何我这里不生效呢。<br>结合之前hexo 5.0 对yilia主题使用的一些坑和网上的吐槽,我觉得有理由猜测,hexo 5.x 版本，更新了对域名和项目名的处理逻辑,导致图片重复拼接了两次项目名。</p>]]></content>
      
      
      <categories>
          
          <category> hexo配置使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
