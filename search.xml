<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo 使用主题butterfly</title>
      <link href="/2021/05/22/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2021/05/22/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="使用butterfly主题后-如何为文章添加本地的封面"><a href="#使用butterfly主题后-如何为文章添加本地的封面" class="headerlink" title="使用butterfly主题后,如何为文章添加本地的封面"></a>使用butterfly主题后,如何为文章添加本地的封面</h2><p>启用文章封面设置后, 可以在文章的头部设置cover属性,使用外连最简单</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">……</span></span><br></pre></td></tr></table></figure><p>但如果没有图床,又想设置内容,则可以尝试在项目目录下,自行放置图片,并在头部进行引用。<br>也可以在贴图文件夹中存放,但是cover地址，则需要设置成打包后查看该图片的地址<br><code>cover: ./2021/05/22/hexo配置与使用/hexo使用butterfly主题/backage.jpg</code></p>]]></content>
      
      
      <categories>
          
          <category> hexo配置使用 </category>
          
          <category> butterfly主题设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 使用配置</title>
      <link href="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo图片不展示"><a href="#hexo图片不展示" class="headerlink" title="hexo图片不展示"></a>hexo图片不展示</h2><p>图片不展示时，观察图片src的路径是否有误。曾出现过在列表全展示时无法查看图片，点进具体博文后可展示图片的异常。</p><span id="more"></span><p>日常使用 Markdown 编写时,都会将静态资源贴到同名文件夹下,通常由文档工具(如<code>Typora</code>、<code>VsCode</code>) 自动配置完成, .md文件与外部文件夹同级别,兼顾文档与静态文件的归类和美观。<br>形如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├ test-blog              (存放图片等静态资源的文件夹)</span><br><span class="line">|   ├ a.png</span><br><span class="line">|   └ b.png</span><br><span class="line">└ test-blog.md           (markdown文件)</span><br></pre></td></tr></table></figure><p>而在<code>hexo</code>的设定中,外层配置文件<code>_config.yml</code>中存在属性<code>post_asset_folder</code>，它控制着是否携带静态资源打包到目录中，默认值是<code>false</code>,只有设置为<code>ture</code>, 才会将静态资源打包到html同级目录下。形如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">  └ 2019</span><br><span class="line">      └ 08</span><br><span class="line">         └ 21</span><br><span class="line">            └ test-blog</span><br><span class="line">                ├ index.html        (markdown文件被编译后生成的.html文件)</span><br><span class="line">                ├ a.png</span><br><span class="line">                └ b.png             (文件引用的静态图片,如果不更改属性post_asset_folder为true, 则编译后该目录下不会生成这些图片)</span><br><span class="line"></span><br><span class="line">(明显编译后的结构也和源文件的存放路径不相同)</span><br></pre></td></tr></table></figure><p>此时启动项目后,会发现请求静态资源时路径中出现了两次文件夹名称。 形如: <code>http://localhost:5000/2022/08/03/test-bolg/test-bolg/a.png</code> ,其中/test-blog文件夹名出现了两次，页面中查看该文章时，就无法显示图片内容。<br>而如果保持属性<code>post_asset_folder</code>修改为<code>false</code>, 生成文章html中,读取图片的路径是正确的(形如:<code>http://localhost:5000/2022/08/03/test-bolg/a.png</code>), 路径虽然正确,但却因为静态资源没有被编译,导致同样无法展示图片。</p><p>换个说法就是官方 希(只)望(支)你(持) 把md文件和图片放在同一级。形如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test-blog</span><br><span class="line">   ├ a.png</span><br><span class="line">   ├ b.png</span><br><span class="line">   └ test-blog.md</span><br></pre></td></tr></table></figure><p>在查找资料时,多个资料都有提到插件 <code>hexo-asset-image</code> 专门用来解决问题, 但我使用 <code>npm install hexo-asset-image --save</code> 后, 图片路径依旧存在问题。最终在一篇帖子里，找到插件不可用的原因。</p><p><strong>解决方案</strong></p><p>1.将属性<code>post_asset_folder</code>修改为<code>true</code></p><p>2.必须使用 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code> 安装0.0.5版本的hexo-asset-image插件。</p><p>这里解释下, 从github上访问项目’<a href="https://github.com/CodeFalling/hexo-asset-image&#39;">https://github.com/CodeFalling/hexo-asset-image&#39;</a> 时,其链接地址也做了自动转发,也就是到了新版本的<code>hexo-asset-image</code>, 而在新版本的readme文档中,其推荐使用安装命令 <code>npm install hexo-asset-image --save</code>, 得到的是1.0.0版本，但正因为版本映射的不同，必须使用旧版本插件才能解决图片资源的问题。 </p><p>(关于这一点，也许在hexo的新版本，或者插件的作者会做更新调整。当前的解决方案有一点局限性，持续观望中…)</p><p>参考地址:<a href="https://www.jianshu.com/p/db02d775aed0">https://www.jianshu.com/p/db02d775aed0</a><br><br><br><br></p><h2 id="hexo在码云上使用时的样式和图片404异常"><a href="#hexo在码云上使用时的样式和图片404异常" class="headerlink" title="hexo在码云上使用时的样式和图片404异常"></a>hexo在码云上使用时的样式和图片404异常</h2><p>hexo 博客搭桥到github 对 _config.yml 下的配置基本没有改动。但同样的配置部署到gitee后,却出现样式文件404导致显示出现很多异常。</p><p>异常内容形如<br><img src="/myblog/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/350307b1.png"></p><p>百度了很多的帖子,也翻阅了gitee的API文档 <a href="https://gitee.com/help/articles/4136#article-header0" title="码云Pages">码云Pages</a><br>大致都是说由于gitee部署的page服务,使用的域名后携带了项目名称,导致样式文件和图片的相对路径不正常,本地预览博客正常,上线后会出错。 于是在 _config.yml 中进行了如下配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://buqiugouda.gitee.io/myblog</span><br><span class="line">root: /myblog</span><br></pre></td></tr></table></figure><p>hexo clean; hexo g; hexo d 重新手动部署page服务后,发现主页的样式文件已经没有问题了. 但是正文里的图片还是无法正常显示.<br><img src="/myblog/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/b2f00f08.png"></p><p>得确很多帖子都是这么处理的，也有博主进行贴图,评论区表示感谢的,怎么到了我这里问题只解决了一半。于是调出控制台,发现找不到的图片引用都是重复了两次项目名 /myblog<br>public中编译得到的静态文件,其指向图片的引用也是两次 /myblog, 实际本地启动的服务,也有同样的情况,只是我误以为gitee上部署后,会通过域名映射啥的解决这个问题.</p><p>我决定只配一次项目名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://buqiugouda.gitee.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/myblog</span></span><br></pre></td></tr></table></figure><p>本地启动展示效果图<br><img src="/myblog/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/8eb68b1b.png"></p><p>提交后重新部署gitee后的效果图<br><img src="/myblog/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/2f880909.png"></p><p>问题解决.但的确多数的帖子和gitee的官方文档都是如此处配置的,也有评论对对第一种配置表示感谢,他们一定也解决了他们的问题,为何我这里不生效呢。<br>结合之前hexo 5.0 对yilia主题使用的一些坑和网上的吐槽,我觉得有理由猜测,hexo 5.x 版本，更新了对域名和项目名的处理逻辑,导致图片重复拼接了两次项目名。</p>]]></content>
      
      
      <categories>
          
          <category> hexo配置使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/2019/11/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>设计模式主要分为创建型、结构性、行为型三大类。创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题</p><p><img src="/2019/11/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/1675181142337.jpg" alt="1675181142337"></p><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC 容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><p>除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式包括简单工厂、工厂方法、抽象工厂这 3 种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过 new 来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面 4 个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>工厂模式一个非常经典的应用场景：依赖注入框架，比如 Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI 框架已经成为了我们平时开发的必备框架.</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li><li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li><li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。通常深拷贝是比较稳妥的做法,除非操作非常耗时,且共享数据不会被篡改时,推荐使用浅拷贝,否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这 5 种场景：</p><ul><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口适配</li><li>不同格式的数据</li></ul><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>行为型模式比较多，有 11 种，它们分别是：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成 EventBus 框架来达到这样的效果。EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><p>除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如 JdbcTemplate 就是用了回调。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</p><p>在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有 3 个优势：</p><ul><li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li><li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li><li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li></ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><p>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p><p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p><p>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到 Double Disptach。如果某种语言支持 Double Dispatch，那就不需要访问者模式了。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h3 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h3><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令手册</title>
      <link href="/2019/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2019/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Linux/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table><h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核/OS/CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat /proc/version</td><td>查看linux版本信息</td></tr><tr><td>cat /proc/cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat /proc/interrupts</td><td>查看中断</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal /proc/meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree /proc/meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu/内存/进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写/cpu使⽤情况</td></tr><tr><td>查看io读写/cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh /dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * | sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount /dev/hda2 /mnt/hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso /mnt/cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v /dev/sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v /mnt/mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km /mnt/hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table><h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr></tbody></table><h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP/UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0/0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0/16’</td></tr><tr><td>route del 0/0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com/">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef | grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig –list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table><h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ../..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名/移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir/* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件/⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件/⽬录的物理链接</td></tr><tr><td>find / -name file1</td><td>从跟⽬录开始搜索⽂件/⽬录</td></tr><tr><td>find / -user user1</td><td>搜索⽤户user1的⽂件/⽬录</td></tr><tr><td>find /dir -name *.bin</td><td>在⽬录/dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件/可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table><h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f /log/msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s/s1/s2/g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘/^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘/ *#/d; /^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘/s1/p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s/ *$//‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s/s1//g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table><h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C /dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table><h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q –whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q –whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q –changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh –test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh –nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table><h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install –downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table><h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装/更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table><h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装/升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(JVM - 二)详解class的加载过程</title>
      <link href="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="详解class的加载过程"><a href="#详解class的加载过程" class="headerlink" title="详解class的加载过程"></a>详解class的加载过程</h1><h2 id="一、Java从编码到执行"><a href="#一、Java从编码到执行" class="headerlink" title="一、Java从编码到执行"></a>一、Java从编码到执行</h2><p>首先我们来看一下Java是如何从编码到执行的呢？ 我们有一个x.java文件通过执行javac命令可以变成x.class文件，当我们调用Java命令的时候class文件会被装载到内存中，这个过程叫做classloader。一般情况下我们自己写代码的时候会用到Java的类库，所以在加载的时候也会把Java类库相关的类也加载到内存中。装载完成之后会调用字节码解释器和JIT即时编译器来进行解释和编译，编译完之后由执行引擎开始执行，执行引擎下面对应的就是操作系统硬件了。下图是大体的流程：</p><span id="more"></span><p><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-05-32.png"></p><p>Java叫做跨平台的语言，JVM可以称之为跨语言的平台；</p><!--more--><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>1.解释器： bytecode intepreter</p><p>2.jit：just in-time compiler</p><p>3.混合模式：</p><p>混合使用解释器+热点代码编译 进行组合，起始阶段采用解释执行<br>热点代码检测 -多次被调用的代码 - 多次被调用的循环 -进行本地编译<br>-Xmixd :默认为混合模式，启动速度较快，对热点代码实行检测和编译；<br>-Xint:使用纯解释模式，启动很快，执行稍慢 ；<br>-Xcomp:  使用纯编译模式，执行很快，启动稍慢。</p><p>有个问题:java是解释执行还是编译执行？</p><blockquote><p>答：解释和编译是可以混合的，特别常用的代码或者是代码用到的次数特别多的时候，会把一个即时编译做成本地编译，这样会很大程度上的提高效率。</p></blockquote><p>Java虚拟机是如何做到这么多语言都可以在上面运行，关键在于class文件，任何语言只要能编译成class文件，并且符合class文件的规范你就可以放在Java虚拟机上去运行。</p><h2 id="二、详解class文件的加载过程"><a href="#二、详解class文件的加载过程" class="headerlink" title="二、详解class文件的加载过程"></a>二、详解class文件的加载过程</h2><p>接下来主要讲的是一个class文件是怎么从硬盘上到内存中，并开始执行的。</p><p>类加载主要有三个过程：loading 、linking 、initializing；其中linking又分为三个步骤：verification 、preparation 、resolution；<br><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-09-35.png"></p><p>1、首先Loading是什么意思呢？是把一个class文件load到内存中去；</p><p>2、接下来是Linking分为了三小步：</p><ul><li>verification  是用来校验加载进来的class文件是否符合class文件标准，如果不符合直接就会被classloader直接拒绝；</li><li>preparation  是将class文件静态变量赋默认值而不是初始值，例如static int i =8；这个步骤并不是将i赋值为8，而是赋值为默认值0；</li><li>resolution  是把class文件常量池中用到的符号引用转换成直接内存地址，可以访问到的内容；<br>3、initializing  称为初始化，静态变量在这个时候才会被赋值为初始值；</li></ul><h2 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h2><h3 id="双亲委派机制概述"><a href="#双亲委派机制概述" class="headerlink" title="双亲委派机制概述"></a>双亲委派机制概述</h3><p>类加载器的加载过程是分成不同的层次来加载的，不同的类加载器来加载不同的class文件，  Bootstrap &gt;Extension&gt;Application&gt;Custom(自定义类加载器)，其遵循的加载策略即是双亲委派机制。</p><p>下面为类加载过程(双亲委派)的简化图：<br><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200629165000263-2051250630.png"></p><p>1、第一个类加载器的层次为：Bootstrap 称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库。</p><p>2、第二个类加载器的层次为：Extension 是用来加载扩展类的，主要负责加载Java的扩展类库,默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar包。</p><p>3、第三个类加载器的层次为：Application 又称为系统类加载器,负责在JVM启动时,加载来自在命令java中的classpath或者java.class.path系统属性或者CLASSPATH操作系统属性所指定的JAR类包和类路径。</p><p>4、第三个类加载器的层次为：CustomClassLoader(自定义加载器)  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Bootstrap加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> property.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Ext加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property1</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> property1.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------App加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property2</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> property2.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/**输出结果只截取了部分*/</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\resources.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\rt.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\sunrsasign.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jsse.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jce.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jfr.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\classes</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext</span></span><br><span class="line">        <span class="comment">//C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\deploy.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\access-bridge-64.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\cldrdata.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\dnsns.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jaccess.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jfxrt.jar</span></span><br></pre></td></tr></table></figure><p>下图为类加载的一个全过程：<br><img src="/myblog/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200630084433768-1150504306.png"><br>用比较通俗的话来解释这个过程，当有一个类需要被加载时，首先要判断这个类是否已经被加载到内存中。判断加载与否的过程是自下而上的，如果class类有自己定义的类加载器，会先到CustomClassLoader 管理的cache（缓存）中去找是否已经加载，若已加载直接返回结果，否则到上层加载器ApplicationClassLoader的cache中查找，如果已经存在直接返回，如果不存在，到Extension中查找，存在直接返回，不存在继续向父加载器中寻找直到Bootstrap顶层，如果依然没找到，那就是没有加载器加载过这个类。需要委派对应的加载器来加载，上层加载器先看看这个类是否在自己的加载范围内，如果是直接加载返回结果，若不是继续向下委派，以此类推直到最下级，如果最终也没能加载，就会直接抛异常 ClassNotFoundException，这就是双亲委派模式的流程。</p><h3 id="理解双亲委派模式"><a href="#理解双亲委派模式" class="headerlink" title="理解双亲委派模式"></a>理解双亲委派模式</h3><p>1、父加载器：不是类加载器的加载器，也不是类加载器的父类加载器（此处意思是没有父类与子类之间的继承关系）。<br>通常会将 BootstrapClassLoader 称为 ExtensionClassLoader 的父加载器；<br>ExtensionClassLoader 称为 ApplicationClassLoader 的父加载器；<br>ApplicationClassLoader 称为 CustomClassLoader 的父加载器；<br>但这个父子关系并不代表着JAVA语法中的继承，而更形象的只是一种语义上的关联，实际就是ClassLoader的类中有一个成员变量parent指向了其关联的ClassLoader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证了父加载器不是加载器的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentAndChild</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//AppClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null  这里AppClassLoader的加载器不是ExtClassLoader  而是Bootstrap</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">appclassLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getClass().getClassLoader();</span><br><span class="line">        System.out.println(appclassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ExtClassLoader   AppClassLoader的父加载器是ExtClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**输出结果*/</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@23fc625e</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException at com.example.demo.classloader.ParentAndChild.main(ParentAndChild.java:22)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、双亲委派：其工作原理的是，如果一个类加载器收到了类加载请求，并不会直接去加载，而是自下而上的向顶层类加载器查找是否已经被加载了，如果被加载就不用进行加载，如果未被加载过，则会自上而下的检查是否属于自己加载的范围，如果属于则加载，如果不属于则向下委托，直到类被加载进来才能叫做成功，如果加载不成功就会抛异常classnotfoundexeption,这就叫做双亲委派。</p><p>3、为什么要搞双亲委派模式？</p><p>主要是为了安全，这里可以使用反证法，如果任何类加载器都可以把class加载到内存中，我们就可以自定义类加载器来加载Java.lang.string。在打包时可以把密码存储为String对象，偷偷摸摸的把密码发送到自己的邮箱，这样会造成安全问题。</p><h2 id="四、自定义类加载器"><a href="#四、自定义类加载器" class="headerlink" title="四、自定义类加载器"></a>四、自定义类加载器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderByHand</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = ClassLoaderByHand.class.getClassLoader().</span><br><span class="line">                loadClass(<span class="string">&quot;com.example.demo.threaddemo.juc_002.Account&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 输出结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//com.example.demo.threaddemo.juc_002.Account</span></span><br></pre></td></tr></table></figure><p>代码运行结果可以看出，若要加载一个类你只要调用classLoader中的 loadClass()方法就能把这个类加载到内存中，加载完成之后会给你返回一个Class类的对象。</p><p>在硬盘上找到这个类的源码，把它load到内存，与此同时生成一个Class对象，上述的小程序是通过 ClassLoaderByHand 找到他的加载器AppClassLoader 然后调用它的loadClass()方法，让它帮我们把 Account类加载进来，返回一个clazz对象，使用clazz.getName()方法正常返回Account类。</p><blockquote><p>什么时候我们需要自己定义去加载一个类？</p><ul><li>热部署时就是先把之前加载的类给干掉 ，然后使用的自定义类加载器来进行重新加载</li><li>spring的动态代理，一个新的class 当需要的时候就会把它load到内存中</li></ul></blockquote><h3 id="ClassLoader的源码分析"><a href="#ClassLoader的源码分析" class="headerlink" title="ClassLoader的源码分析"></a>ClassLoader的源码分析</h3><p>我们还是来看一下ClassLoader的源码，加载过程最主要的还是ClassLoader中的loaderClass()方法：</p><p> 结合上面给的类加载过程的图解一起看会更容易一些；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在加载之前先调用findLoadedClass()方法查看是否已经加载过此类</span></span><br><span class="line"><span class="comment">             * 若加载过 返回该对象</span></span><br><span class="line"><span class="comment">             * 如果未加载则返回null 进行下一步</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//判断有无父加载器 如果不为空说明还未到顶层Bootstrap递归调用loadClass()</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果没有父加载器说明调用的加载器为Bootstrap Class Loader, 在此加载器内存中查找是否已经加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若以上的操作都没成功加载此类</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//调用自己的findClass()</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义classLoader"><a href="#自定义classLoader" class="headerlink" title="自定义classLoader"></a>自定义classLoader</h3><p>1.继承ClassLoader抽象类 extends ClassLoader<br>2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int off, int len)<br>3.加密（可以对class字节码文件进行加密处理，可选）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.FileUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.log.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 继承ClassLoader抽象类 extends ClassLoader</span></span><br><span class="line"><span class="comment"> * 2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int</span></span><br><span class="line"><span class="comment"> * 3.加密（可以对class字节码文件进行加密处理，可选）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0B10110110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 findClass 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.myclass&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != <span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b ^ seed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//defineClass最终将二进制流转换为Class类对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对旧class文件的处理,可选，此方法中使用按位取反</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classFileBasePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classPackagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encFile</span><span class="params">(String classFileBasePath, String classPackagePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePahtWithoutSuffix</span> <span class="operator">=</span> classFileBasePath.concat(<span class="string">&quot;/&quot;</span>).concat(classPackagePath.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//旧的class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">oldFis1</span> <span class="operator">=</span> FileUtil.getInputStream(oldClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.myclass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">newFos</span> <span class="operator">=</span> FileUtil.getOutputStream(newClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (oldFis1.read() != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//按位取反</span></span><br><span class="line">            newFos.write(b ^ seed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldFis1.close();</span><br><span class="line">        newFos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        encFile(classFileBasePath, classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> (Hello) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        h.sayHello();</span><br><span class="line"></span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l是由&#123;&#125;加载而来&quot;</span>, l.getClass().getClassLoader());</span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l的父加载器是&#123;&#125;&quot;</span>, l.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、破坏双亲委派机制"><a href="#五、破坏双亲委派机制" class="headerlink" title="五、破坏双亲委派机制"></a>五、破坏双亲委派机制</h2><p>1.如何破坏双亲委派模型？</p><p>通过重写loadClass()方法。</p><p>2.什么时候破坏过双亲委派模型？</p><blockquote><ul><li>JDK1.2之前，自定义classLoader都必须重写loadClass ()方法。（缺陷）</li><li>ThreadContextClassLoader可以实现基础类调用实现类的代码</li><li>热启动/热部署  tomcat 都有自己的模块指定classLoader（可以加载同一类库的不同版本）</li></ul></blockquote><p>当下也就只能对自定义的class实现打破双亲委派的策略来加载</p><p>破坏双亲委派模型的简单实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重新loadClass方法来打破双亲委派机制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li on 2020/9/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.tiny.security.util.Hello cannot be cast to com.tiny.security.util.Hello</span></span><br><span class="line">        <span class="comment">//Hello h1old = (Hello) clazz.newInstance();</span></span><br><span class="line">        <span class="comment">//h1old.sayHello();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h1</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h1.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在此处断点后，修改hello方法中的输出内容，并重新编译生成新的class</span></span><br><span class="line"><span class="comment">            观察两次输出的内容,可以判定class是否被重新加载了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> l2.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h2</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz2.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h2.sayHello();</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>原文/参考链接<br>calss 加载过程: <a href="https://www.cnblogs.com/dongl961230/p/13212080.html">https://www.cnblogs.com/dongl961230/p/13212080.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JVM调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区域截图异常问题排查</title>
      <link href="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>上个月开发了一个业务功能，整体的流程是通过配置的定时任务，在触发时刻将使用谷歌的爬虫工具selenium在后台通过用户的身份登录公司的报表系统门户中，查看配置的某些报表，进行截图后将图片信息结合配置的内容排版，通过邮件发送到用户邮箱中。就是这样一个简单的需求，但缺因为自己的不细心不自信，加上连续遇上了两个外部jar包的bug，耗费了一整天的时间还加班到凌晨。</p><span id="more"></span><p>区域截图的处理示意图<br><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595324550060.png"></p><ol><li>打开报表时，先定位div元素的起点坐标和元素宽高，并截取全屏的图片</li><li>使用区域截图的方法结合第1步记录的信息，只截取报表展示区域的图片内容</li></ol><h2 id="异常描述"><a href="#异常描述" class="headerlink" title="异常描述"></a>异常描述</h2><p>原本简单的截图需求，在多次使用截图方法后，输出的截图文件却始终不合规范。</p><h3 id="代码贴图"><a href="#代码贴图" class="headerlink" title="代码贴图"></a>代码贴图</h3><ol><li>通过谷歌浏览器驱动进行截图的代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取多张管理画布的截图页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName  登录用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> passWord  用户密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reportIdList  需要查看的管理画布报表的id列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, File&gt; <span class="title function_">dataexplorScreenShotMap</span><span class="params">(String userName, String passWord, List&lt;String&gt; reportIdList)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置驱动地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">driverPath</span> <span class="operator">=</span> getChromeDriverPathByOs();</span><br><span class="line"></span><br><span class="line">    HtmlScreenshotSettingParam.settingParamInit();</span><br><span class="line"></span><br><span class="line">    System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, driverPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">ChromeOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeOptions</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是要执行的命令，不打开浏览器窗口的方式，如需修改截图页面的尺寸，修改--window-size的参数即可</span></span><br><span class="line">    options.addArguments(</span><br><span class="line">            <span class="string">&quot;--headless&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--disable-gpu&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--ignore-certificate-errors&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定模拟打开浏览器的窗口的宽高</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;--window-size=1440,1200&quot;</span>;</span><br><span class="line"></span><br><span class="line">    options.addArguments(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 先进行登录</span></span><br><span class="line">    <span class="type">WebDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeDriver</span>(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问页面</span></span><br><span class="line">    driver.get(HtmlScreenshotSettingParam.DAP_LOGIN_PAGE_URL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//账号密码，按钮  ，直接模拟登录</span></span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;login_name&quot;</span>)).sendKeys(userName);</span><br><span class="line"></span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;user_cipher&quot;</span>)).sendKeys(passWord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟点击登录按钮</span></span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;btnSubmit&quot;</span>)).click();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定等待时间供连接访问</span></span><br><span class="line">    Thread.sleep(HtmlScreenshotSettingParam.PAGE_LOADING_WAITING_TIME);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; ImageMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, File&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String canvasReportId : reportIdList) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结合报表的id，构造报表的展示地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reportUrl</span> <span class="operator">=</span> HtmlScreenshotSettingParam.CANVAS_REPORT_MODEL_URL.replace(<span class="string">&quot;&#123;reportId&#125;&quot;</span>, canvasReportId);</span><br><span class="line"></span><br><span class="line">        driver.get(reportUrl);</span><br><span class="line"></span><br><span class="line">        driver.navigate().refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.登录后访问报表地址</span></span><br><span class="line">        logger.info(<span class="string">&quot;当前展示的页签名称:&quot;</span> + driver.getTitle());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(HtmlScreenshotSettingParam.PAGE_LOADING_WAITING_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到截图的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">screenshotFile</span> <span class="operator">=</span> ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换格式</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">screenshotFormatFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>( screenshotFile.getPath().replace(<span class="string">&quot;.png&quot;</span>, HtmlScreenshotSettingParam.ImageFormat));</span><br><span class="line"></span><br><span class="line">        ImgUtil.convert(screenshotFile, screenshotFormatFile);</span><br><span class="line"></span><br><span class="line">        screenshotFile = screenshotFormatFile;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图,只获取管理画布内容</span></span><br><span class="line">        screenshotFile = regionalScreenshots(driver, screenshotFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((screenshotFile != <span class="literal">null</span>) &amp;&amp; screenshotFile.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            ImageMap.put(canvasReportId, screenshotFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver.quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ImageMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>区域截图的处理逻辑方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile 完整的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;进入画布的区域截图方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                + screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制完整的图片文件</span></span><br><span class="line">        FileUtils.copyFile(screenshotFile, cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找画布div节点</span></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//矩形图像对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x、y表示加上当前frame的左边距,上边距</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">dest</span> <span class="operator">=</span> image.getSubimage(point.x, point.y, rect.width, rect.height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写出截图文件</span></span><br><span class="line">        ImageIO.write(dest, <span class="string">&quot;png&quot;</span>, cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + cacheShotPic.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheShotPic;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常规登录页面获取管理画布</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataexplorScreenShotMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;cw&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">passWord</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String[] reportIdArr = &#123;&quot;24160932063991478208&quot;, &quot;50582076917040768340&quot;, &quot;50570813594059717529&quot;&#125;;</span></span><br><span class="line">    String[] reportIdArr = &#123;<span class="string">&quot;243945938171462886942&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; reportIdList = Arrays.asList(reportIdArr);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; imageMap = HtmlScreenshotUtil.dataexplorScreenShotMap( userName, passWord, reportIdList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;调用工具类后,取得截图文件:&quot;</span> + imageMap.keySet().size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key : imageMap.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">imageFile</span> <span class="operator">=</span> imageMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/&quot;</span> + key + <span class="string">&quot;_&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">            FileUtil.copy(imageFile, <span class="keyword">new</span> <span class="title class_">File</span>(pathname));</span><br><span class="line"></span><br><span class="line">            System.out.println(pathname);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>截取的图片文件预览</li></ol><ul><li>完整截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot4011539626072935834_complete_20200721205449.jpg"></li><li>区域截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/243945938171462886942_1595335555972.png"></li></ul><p>这显然不是我们想要的结果,  但是本人从代码层面没有发现明显的异常。也是由于工作中对图片的处理用的比较少，不太确定代码的正确性。</p><h2 id="试错过程"><a href="#试错过程" class="headerlink" title="试错过程"></a>试错过程</h2><p>由于没能找到当前代码中的异常，于是换了其他的处理逻辑。想起此前领导案例的一个”优秀的”第三方工具包hutool，查看其文档后，发现其中也有图片处理的方法，maven引用也很便捷。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-captcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hutool 中包含两个类似的图片工具类</p><ul><li><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片工具-ImgUtil">图片工具-ImgUtil</a></li><li><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片编辑器-Img">图片编辑器-Img</a></li></ul><p>阅读相关的文档并，我选择了图片编辑器中的图像切割，因为后续也会使用到图片的缩放，链式调用使得代码很简洁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"><span class="comment">//矩形裁剪</span></span><br><span class="line">    .cut(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height))</span><br><span class="line"><span class="comment">//缩放</span></span><br><span class="line">    .scale(<span class="number">900</span>,<span class="number">600</span>)</span><br><span class="line"><span class="comment">//写出</span></span><br><span class="line">    .write(FileUtil.file(screenshotFile));</span><br></pre></td></tr></table></figure><h3 id="使用hutool-图片编辑器裁剪图片"><a href="#使用hutool-图片编辑器裁剪图片" class="headerlink" title="使用hutool-图片编辑器裁剪图片"></a>使用hutool-图片编辑器裁剪图片</h3><ol><li>修改后的区域截图方法代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容 - 使用hutool 的图片编辑器进行裁剪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                +screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的全屏文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheCompletePic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"></span><br><span class="line">                .cut(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height))</span><br><span class="line"></span><br><span class="line">                .scale(HtmlScreenshotSettingParam.canvasScaleWidth, HtmlScreenshotSettingParam.canvasScaleHighth)</span><br><span class="line"></span><br><span class="line">                .write(FileUtil.file(screenshotFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的区域截图文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheShotPic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试方法运行图效果</li></ol><ul><li><p>完整截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot263478830502424703_complete_20200722100018.jpg"></p></li><li><p>区域截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot263478830502424703_shot_20200722100018.jpg"><br>同样，截图的区域不是预期的效果。而且对于相同的矩形起点和宽高，为何两种方案截图出来的效果都不一致？真叫人头大。</p></li></ul><h3 id="穷举测试"><a href="#穷举测试" class="headerlink" title="穷举测试"></a>穷举测试</h3><p>我开始破罐子破摔的方式，手动调整截图的起点和范围。试想的方案是，使用之前存下来的全屏的图片文件,  本地编写矩形区域的真实宽高，重复尝试着确认起始点的坐标，观察截图文件的内容。<br>此时已经变更截图方法为 hutool-图片编辑器 的截图方法，故以此编写了测试类</p><ol><li>正常宽高测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/画布div起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, width, highth);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle1)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/原点起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试效果图</p><ul><li><p>以画布坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E7%94%BB%E5%B8%83div%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li><li><p>以原点坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8E%9F%E7%82%B9%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li></ul><p>几张图片的尺寸是一致的，但是实际截取的范围都比画布的尺寸更小。甚至原点都不在图片文件的左上顶点。于是我决定把宽高的范围手动扩大，观察效果。</p><ol start="2"><li>设定双倍宽高<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutDoubleTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width * <span class="number">2</span>, highth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/双倍画布div起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, width * <span class="number">2</span>, highth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle1)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/双倍原点起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试效果图</li></ol><ul><li><p>以画布坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E7%94%BB%E5%B8%83div%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li><li><p>以原点坐标为起点的截图<br>  <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E5%8E%9F%E7%82%B9%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li></ul><p>看到第二张图的效果，除了顶部的灰色条，几乎都完美的解决了我的问题。再次尝试修改坐标位置，截取得到了只包含画布的微调截图范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line"><span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, y, width * <span class="number">2</span>, highth * <span class="number">2</span> - y);</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E5%8E%9F%E7%82%B9%E5%BE%AE%E8%B0%83%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p><p>由于需要赶进度，就按照这种改动设定了宽高和坐标轴，对代码进行了提交。此时对截取的范围的选择和理解，依旧和java的截图矩形类的定义不一致 ，逻辑上其实是不正确的。<br>而代码提交后，交付到运维同事，他本地拉取代码部署运行后。通过邮件接收到的截图内容，简直堪称离谱。和我本地的测试效果完全不一样。<br><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595396629702.png"></p><h3 id="补全日志信息"><a href="#补全日志信息" class="headerlink" title="补全日志信息"></a>补全日志信息</h3><p>我确定代码是一致的，但是运行效果的差异，这让我意识到也许和操作系统环境有关。我本地使用mac系统，同时用的windows机器，部署上线的又是linux系统中。由于最初编码的时候，实际并没有上述代码块中那么多详细的日志，为了对比具体的执行差异，才在方法中补全了足够详细的日志记录。 也翻出了我家里的老伙计，辅助做印证测试。</p><p>mac上执行截图的测试方法,从控制台看到本次执行过程打印的日志</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">42</span>,<span class="number">402</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">252</span> - 当前展示的页签名称:<span class="number">2020</span>进阶趋势 › page1</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">358</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">613</span> - 进入画布的区域截图方法</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">374</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">643</span> - 留存当前图片的全屏内容,存放位置 /<span class="symbol">Users</span>/buqiugouda/.oldsemf/chromedriver/screenshot/screenshot5254156389223784299_complete_20200722135053.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">460</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">647</span> - 当前全屏文件的宽度:<span class="number">2880</span> 高度:<span class="number">2400</span></span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">478</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">654</span> - 当前全屏文件包含了画布的区域,起点坐标(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">489</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">661</span> - 当前画布内容的宽度:<span class="number">840</span> 高度:<span class="number">1190</span></span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">54</span>,<span class="number">045</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">675</span> - 留存当前图片的区域截图内容,存放位置 /<span class="symbol">Users</span>/buqiugouda/.oldsemf/chromedriver/screenshot/screenshot5254156389223784299_shot_20200722135053.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">54</span>,<span class="number">054</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">679</span> - 当前区域截图文件经过指定尺寸缩放后的宽度:<span class="number">800</span> 高度:<span class="number">900</span></span><br></pre></td></tr></table></figure><p>windows上执行截图测试方法，从控制台看到本次执行过程打印的日志</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">04</span>,<span class="number">778</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">252</span> - 当前展示的页签名称:<span class="number">2020</span>进阶趋势 › page1</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">265</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">613</span> - 进入画布的区域截图方法</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">272</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">643</span> - 留存当前图片的全屏内容,存放位置 <span class="symbol">D</span>:\\oldsemf\chromedriver\screenshot\screenshot2057483932069022115_complete_20200722135711.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">355</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">647</span> - 当前全屏文件的宽度:<span class="number">1440</span> 高度:<span class="number">1200</span></span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">373</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">654</span> - 当前全屏文件包含了画布的区域,起点坐标(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">385</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">661</span> - 当前画布内容的宽度:<span class="number">840</span> 高度:<span class="number">1190</span></span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">901</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">675</span> - 留存当前图片的区域截图内容,存放位置 <span class="symbol">D</span>:\\oldsemf\chromedriver\screenshot\screenshot2057483932069022115_shot_20200722135711.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">908</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">679</span> - 当前区域截图文件经过指定尺寸缩放后的宽度:<span class="number">800</span> 高度:<span class="number">900</span></span><br></pre></td></tr></table></figure><p>重点落在首次截取的全屏图片文件的宽高上，mac上截得文件的宽高居然是windows上的两倍。而我在代码中调用谷歌驱动时，分明指定了模拟浏览器打开时，窗口的宽高为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定模拟打开浏览器的窗口的宽高</span></span><br><span class="line"><span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;--window-size=1440,1200&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>这就说明mac截图下来的文件，自行将图片宽高扩大了一倍！当然这个bug，谷歌浏览器驱动包 selenium-chrome-driver 依赖jar包中的截图方法，与当前mac 系统的版本号，我安装的浏览器版本 更具体的对应关系是否有关就不得而知。</strong></p><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><p>新编写一个测试类，将历史测试数据中的完整截图先等比缩放以后再进行矩形区域的截图。<br>使用hutool 图片编辑器提供的缩放裁剪链式调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍 - 再进行截图</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).cut(rectangle).write(cacheShotPic);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图<br>    <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595405941568.png"></p><p>(几近崩快，居然还是没能正确地截取！！！)</p><h3 id="对比测试"><a href="#对比测试" class="headerlink" title="对比测试"></a>对比测试</h3><p>既然出现了 selenium-chrome-driver 外部依赖的bug，完全有理由怀疑 hutool 提供的截图方法存在bug.<br>使用java的 BufferedImage 的截取方法进行截取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompleteScalePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图-等比缩放.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompleteScalePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).write(cacheCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">img</span> <span class="operator">=</span> ImageIO.read(cacheCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在缩放后的图片上指定范围来截图</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">dest</span> <span class="operator">=</span> img.getSubimage(x, y , width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    ImageIO.write(dest, <span class="string">&quot;png&quot;</span>, cacheShotPic);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图<br>    <img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595406306543.png"></p><p>是的，这足以证明hutool的 <a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片编辑器-Img">图片编辑器-Img</a> 中提供的.cut() 的矩形截图方法是存在bug的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自此已经明确找出两处bug和他们的影响，通过windows机器上的对比可确定解决方案。mac系统上截取的全屏图片由于被拉伸，所以在区域截图前应当先缩放，在用指定的矩形范围和坐标进行截图。最终验证测试了hutool的另一个图片处理工具<br><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片工具-ImgUtil">图片工具-ImgUtil</a> ，发现其矩形截图方法.cut()是同BufferedImage.getSubimage()原理一致的。<br>使用hutool的图片工具ImgUtil编写的测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).write(cacheShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//截取</span></span><br><span class="line">    ImgUtil.cut(cacheCompletePic, cacheShotPic, rectangle);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图</p><p><img src="/myblog/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595407306025.png"></p><p>变更区域截图的处理逻辑方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots0</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;进入画布的区域截图方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                +screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的全屏文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheCompletePic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//浏览器窗口的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowWidth</span> <span class="operator">=</span> driver.manage().window().getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//浏览器窗口的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowHeight</span> <span class="operator">=</span> driver.manage().window().getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把全屏文件的尺寸缩放到与设定窗口的宽高一致，调整图片尺寸后续再截图</span></span><br><span class="line">        Img.from(screenshotFile)</span><br><span class="line">                .scale(windowWidth, windowHeight)</span><br><span class="line">                .write(screenshotFile);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//截图</span></span><br><span class="line">        ImgUtil.cut(screenshotFile, screenshotFile, <span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"></span><br><span class="line">                .scale(HtmlScreenshotSettingParam.canvasScaleWidth, HtmlScreenshotSettingParam.canvasScaleHighth)</span><br><span class="line"></span><br><span class="line">                .write(FileUtil.file(screenshotFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的区域截图文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheShotPic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ol><li>对图片处理的原生方法使用太少，未能根据截取效果第一时间判断，自己是否对矩形范围的坐标和宽高设定有误。</li><li>外部驱动的使用有时候因为技术方案或者业务需求无法变动，但都需要做足够详细的技术验证和测试工作。否则开发工程中的意外试错，将会影响工作效率和进度</li><li>外部的工具包虽然是大牛编写的，但也并不能预知所有的情况。对工具的使用，并不该只停在”拿来主义”，看看它的源码，也能对自己有所帮助。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot-静态页面无法加载</title>
      <link href="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前段时间帮项目上的同事改造一个springboot项目，后端使用springboot框架开发，前端使用node.js编译后将静态资源放到后端自行新增的webapp目录下,  又套用了web.xml等一系列配置将项目改造成了web项目,最终以war包形式进行发布。  </p><span id="more"></span><p>本人的任务是为此项目接入统一认证的平台，使用了已经验证过的拦截器，来实现登录的会话验证。强迫症让我又将项目结构调整为普通的springboot的结构。</p><p>在添加完拦截器之后，后端接口测试基本都一次过,拦截器的逻辑也都符合预期。但是加入静态资源后，进入主页却始终无法引用到相关的静态资源。</p><p><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%BC%82%E5%B8%B8%E4%B8%BB%E9%A1%B50.png"></p><p>而所有单独请求静态资源的url都返回404，查看idea 发现以下日志记录<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%AA%E8%AF%86%E5%88%AB7a3a0a8a.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p> 静态文件结构:<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84f978d5f6.png"></p><p>前端页面的解析使用sprinboot提供的thymeleaf,并在配置文件中完成配置。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/thymeleaf%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%901e5a6d02.png"></p><h2 id="解决问题的流程"><a href="#解决问题的流程" class="headerlink" title="解决问题的流程"></a>解决问题的流程</h2><h3 id="排查资源编译路径"><a href="#排查资源编译路径" class="headerlink" title="排查资源编译路径"></a>排查资源编译路径</h3><p>最初只是注意到页面的空白，以及idea的日志记录，百度后就认定为静态资源无法读取。<br>重新maven编译后，确认target的同目录结构下，是存在相关静态资源的，于是排除了编译问题。</p><h3 id="排查springboot关于静态文件的读取配置"><a href="#排查springboot关于静态文件的读取配置" class="headerlink" title="排查springboot关于静态文件的读取配置"></a>排查springboot关于静态文件的读取配置</h3><p>由于接触的项目跨度比较大，从jsp之后，经手的项目都是前后端分离的。所以去网络上查找也学习了关于静态文件的配置方法。</p><p>参考此文档后 <a href="https://www.jianshu.com/p/a9e6edd46e98">https://www.jianshu.com/p/a9e6edd46e98</a> ,算是理清了静态文件资源的读取规则。<br>于是满怀信心后添加配置<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/springboot%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AEa206d7fd.png"></p><p>但页面依旧没有任何变化。冷静查看 spring.resources.static-locations 指向的默认配置类<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE7a27e960.png"><br>而我的项目中，存放静态资源的位置，本来就位于其中,加上sprongboot默认的静态资源匹配规则就是 /**, 其实我这个项目压根就用不着额外配置</p><p>继续翻阅文章是，注意到springboot早起的版本，对于静态资源的放行，不是直接配置而是放到了拦截器中进行处理。正好我做会话认证的功能也是写在自定义拦截器的实现类中,于是仿写了相关配置在拦截器中进行静态资源的匹配和处理规则。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BBe33b5431.png"></p><p>再次打开项目，进入主页时，异常居然就解决了。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%BB%E9%A1%B5dbf500e7.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>再次审阅我的自定义”拦截器”<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%94%AF%E4%B8%80%E9%85%8D%E7%BD%AE%E7%B1%BB3f5855e9.png"></p><p>等等为什么这个类 是在继承 WebMvcConfigurationSupport, 我的其他项目中使用拦截器似乎有点不同。<br><img src="/myblog/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8567273b7.png"><br>其他项目中使用的都是 WebMvcConfigurer的自定义实现类</p><p>继续搜索了相关资料后, 了解了WebMvcConfigurationSupport 和 WebMvcConfigurer 的区别和关联<br>参考链接: <a href="https://www.jianshu.com/p/c5c1503f5367">https://www.jianshu.com/p/c5c1503f5367</a></p><p>WebMvcConfigurationSupport 在整个应用程序中只会生效一个，如果用户已经实现了 WebMvcConfigurationSupport，则 DelegatingWebMvcConfiguration 将不会生效。换句话来说，WebMvcConfigurer 的所有实现类将不会生效。<br>而在Spring 中，如果类路径上不存在 WebMvcConfigurationSupport 的实例，则将会默认实现WebMvcConfigurerAdapter、DelegatingWebMvcConfiguration 来自定义mvc 配置。</p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>对于我本次改造的项目而言,静态文件的存放路径就在springboot的默认配置路径中,不要额外指定和配置。只需要修改拦截器的实现类，使用 WebMvcConfigurer 的自定义实现类来定义会话拦截器就可以了。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2>]]></content>
      
      
      <categories>
          
          <category> 工作踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
