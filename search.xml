<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo 使用主题butterfly</title>
      <link href="/2021/05/22/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2021/05/22/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="使用butterfly主题后-如何为文章添加本地的封面"><a href="#使用butterfly主题后-如何为文章添加本地的封面" class="headerlink" title="使用butterfly主题后,如何为文章添加本地的封面"></a>使用butterfly主题后,如何为文章添加本地的封面</h2><p>启用文章封面设置后, 可以在文章的头部设置cover属性,使用外连最简单</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">……</span></span><br></pre></td></tr></table></figure><p>但如果没有图床,又想设置内容,则可以尝试在项目目录下,自行放置图片,并在头部进行引用。<br>也可以在贴图文件夹中存放,但是cover地址，则需要设置成打包后查看该图片的地址<br><code>cover: ./2021/05/22/hexo配置与使用/hexo使用butterfly主题/backage.jpg</code></p>]]></content>
      
      
      <categories>
          
          <category> hexo配置使用 </category>
          
          <category> butterfly主题设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 使用配置</title>
      <link href="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo图片不展示"><a href="#hexo图片不展示" class="headerlink" title="hexo图片不展示"></a>hexo图片不展示</h2><p>图片不展示时，观察图片src的路径是否有误。曾出现过在列表全展示时无法查看图片，点进具体博文后可展示图片的异常。</p><span id="more"></span><p>日常使用 Markdown 编写时,都会将静态资源贴到同名文件夹下,通常由文档工具(如<code>Typora</code>、<code>VsCode</code>) 自动配置完成, .md文件与外部文件夹同级别,兼顾文档与静态文件的归类和美观。<br>形如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├ test-blog              (存放图片等静态资源的文件夹)</span><br><span class="line">|   ├ a.png</span><br><span class="line">|   └ b.png</span><br><span class="line">└ test-blog.md           (markdown文件)</span><br></pre></td></tr></table></figure><p>而在<code>hexo</code>的设定中,外层配置文件<code>_config.yml</code>中存在属性<code>post_asset_folder</code>，它控制着是否携带静态资源打包到目录中，默认值是<code>false</code>,只有设置为<code>ture</code>, 才会将静态资源打包到html同级目录下。形如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">  └ 2019</span><br><span class="line">      └ 08</span><br><span class="line">         └ 21</span><br><span class="line">            └ test-blog</span><br><span class="line">                ├ index.html        (markdown文件被编译后生成的.html文件)</span><br><span class="line">                ├ a.png</span><br><span class="line">                └ b.png             (文件引用的静态图片,如果不更改属性post_asset_folder为true, 则编译后该目录下不会生成这些图片)</span><br><span class="line"></span><br><span class="line">(明显编译后的结构也和源文件的存放路径不相同)</span><br></pre></td></tr></table></figure><p>此时启动项目后,会发现请求静态资源时路径中出现了两次文件夹名称。 形如: <code>http://localhost:5000/2022/08/03/test-bolg/test-bolg/a.png</code> ,其中/test-blog文件夹名出现了两次，页面中查看该文章时，就无法显示图片内容。<br>而如果保持属性<code>post_asset_folder</code>修改为<code>false</code>, 生成文章html中,读取图片的路径是正确的(形如:<code>http://localhost:5000/2022/08/03/test-bolg/a.png</code>), 路径虽然正确,但却因为静态资源没有被编译,导致同样无法展示图片。</p><p>换个说法就是官方 希(只)望(支)你(持) 把md文件和图片放在同一级。形如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test-blog</span><br><span class="line">   ├ a.png</span><br><span class="line">   ├ b.png</span><br><span class="line">   └ test-blog.md</span><br></pre></td></tr></table></figure><p>在查找资料时,多个资料都有提到插件 <code>hexo-asset-image</code> 专门用来解决问题, 但我使用 <code>npm install hexo-asset-image --save</code> 后, 图片路径依旧存在问题。最终在一篇帖子里，找到插件不可用的原因。</p><p><strong>解决方案</strong></p><p>1.将属性<code>post_asset_folder</code>修改为<code>true</code></p><p>2.必须使用 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code> 安装0.0.5版本的hexo-asset-image插件。</p><p>这里解释下, 从github上访问项目’<a href="https://github.com/CodeFalling/hexo-asset-image&#39;">https://github.com/CodeFalling/hexo-asset-image&#39;</a> 时,其链接地址也做了自动转发,也就是到了新版本的<code>hexo-asset-image</code>, 而在新版本的readme文档中,其推荐使用安装命令 <code>npm install hexo-asset-image --save</code>, 得到的是1.0.0版本，但正因为版本映射的不同，必须使用旧版本插件才能解决图片资源的问题。 </p><p>(关于这一点，也许在hexo的新版本，或者插件的作者会做更新调整。当前的解决方案有一点局限性，持续观望中…)</p><p>参考地址:<a href="https://www.jianshu.com/p/db02d775aed0">https://www.jianshu.com/p/db02d775aed0</a><br><br><br><br></p><h2 id="hexo在码云上使用时的样式和图片404异常"><a href="#hexo在码云上使用时的样式和图片404异常" class="headerlink" title="hexo在码云上使用时的样式和图片404异常"></a>hexo在码云上使用时的样式和图片404异常</h2><p>hexo 博客搭桥到github 对 _config.yml 下的配置基本没有改动。但同样的配置部署到gitee后,却出现样式文件404导致显示出现很多异常。</p><p>异常内容形如<br><img src="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/350307b1.png"></p><p>百度了很多的帖子,也翻阅了gitee的API文档 <a href="https://gitee.com/help/articles/4136#article-header0" title="码云Pages">码云Pages</a><br>大致都是说由于gitee部署的page服务,使用的域名后携带了项目名称,导致样式文件和图片的相对路径不正常,本地预览博客正常,上线后会出错。 于是在 _config.yml 中进行了如下配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://buqiugouda.gitee.io/myblog</span><br><span class="line">root: /myblog</span><br></pre></td></tr></table></figure><p>hexo clean; hexo g; hexo d 重新手动部署page服务后,发现主页的样式文件已经没有问题了. 但是正文里的图片还是无法正常显示.<br><img src="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/b2f00f08.png"></p><p>得确很多帖子都是这么处理的，也有博主进行贴图,评论区表示感谢的,怎么到了我这里问题只解决了一半。于是调出控制台,发现找不到的图片引用都是重复了两次项目名 /myblog<br>public中编译得到的静态文件,其指向图片的引用也是两次 /myblog, 实际本地启动的服务,也有同样的情况,只是我误以为gitee上部署后,会通过域名映射啥的解决这个问题.</p><p>我决定只配一次项目名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://buqiugouda.gitee.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/myblog</span></span><br></pre></td></tr></table></figure><p>本地启动展示效果图<br><img src="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/8eb68b1b.png"></p><p>提交后重新部署gitee后的效果图<br><img src="/2021/05/21/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/2f880909.png"></p><p>问题解决.但的确多数的帖子和gitee的官方文档都是如此处配置的,也有评论对对第一种配置表示感谢,他们一定也解决了他们的问题,为何我这里不生效呢。<br>结合之前hexo 5.0 对yilia主题使用的一些坑和网上的吐槽,我觉得有理由猜测,hexo 5.x 版本，更新了对域名和项目名的处理逻辑,导致图片重复拼接了两次项目名。</p>]]></content>
      
      
      <categories>
          
          <category> hexo配置使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(JVM - 二)详解class的加载过程</title>
      <link href="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="详解class的加载过程"><a href="#详解class的加载过程" class="headerlink" title="详解class的加载过程"></a>详解class的加载过程</h1><h2 id="一、Java从编码到执行"><a href="#一、Java从编码到执行" class="headerlink" title="一、Java从编码到执行"></a>一、Java从编码到执行</h2><p>首先我们来看一下Java是如何从编码到执行的呢？ 我们有一个x.java文件通过执行javac命令可以变成x.class文件，当我们调用Java命令的时候class文件会被装载到内存中，这个过程叫做classloader。一般情况下我们自己写代码的时候会用到Java的类库，所以在加载的时候也会把Java类库相关的类也加载到内存中。装载完成之后会调用字节码解释器和JIT即时编译器来进行解释和编译，编译完之后由执行引擎开始执行，执行引擎下面对应的就是操作系统硬件了。下图是大体的流程：</p><span id="more"></span><p><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-05-32.png"></p><p>Java叫做跨平台的语言，JVM可以称之为跨语言的平台；</p><!--more--><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>1.解释器： bytecode intepreter</p><p>2.jit：just in-time compiler</p><p>3.混合模式：</p><p>混合使用解释器+热点代码编译 进行组合，起始阶段采用解释执行<br>热点代码检测 -多次被调用的代码 - 多次被调用的循环 -进行本地编译<br>-Xmixd :默认为混合模式，启动速度较快，对热点代码实行检测和编译；<br>-Xint:使用纯解释模式，启动很快，执行稍慢 ；<br>-Xcomp:  使用纯编译模式，执行很快，启动稍慢。</p><p>有个问题:java是解释执行还是编译执行？</p><blockquote><p>答：解释和编译是可以混合的，特别常用的代码或者是代码用到的次数特别多的时候，会把一个即时编译做成本地编译，这样会很大程度上的提高效率。</p></blockquote><p>Java虚拟机是如何做到这么多语言都可以在上面运行，关键在于class文件，任何语言只要能编译成class文件，并且符合class文件的规范你就可以放在Java虚拟机上去运行。</p><h2 id="二、详解class文件的加载过程"><a href="#二、详解class文件的加载过程" class="headerlink" title="二、详解class文件的加载过程"></a>二、详解class文件的加载过程</h2><p>接下来主要讲的是一个class文件是怎么从硬盘上到内存中，并开始执行的。</p><p>类加载主要有三个过程：loading 、linking 、initializing；其中linking又分为三个步骤：verification 、preparation 、resolution；<br><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/2020-09-09-18-09-35.png"></p><p>1、首先Loading是什么意思呢？是把一个class文件load到内存中去；</p><p>2、接下来是Linking分为了三小步：</p><ul><li>verification  是用来校验加载进来的class文件是否符合class文件标准，如果不符合直接就会被classloader直接拒绝；</li><li>preparation  是将class文件静态变量赋默认值而不是初始值，例如static int i =8；这个步骤并不是将i赋值为8，而是赋值为默认值0；</li><li>resolution  是把class文件常量池中用到的符号引用转换成直接内存地址，可以访问到的内容；<br>3、initializing  称为初始化，静态变量在这个时候才会被赋值为初始值；</li></ul><h2 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h2><h3 id="双亲委派机制概述"><a href="#双亲委派机制概述" class="headerlink" title="双亲委派机制概述"></a>双亲委派机制概述</h3><p>类加载器的加载过程是分成不同的层次来加载的，不同的类加载器来加载不同的class文件，  Bootstrap &gt;Extension&gt;Application&gt;Custom(自定义类加载器)，其遵循的加载策略即是双亲委派机制。</p><p>下面为类加载过程(双亲委派)的简化图：<br><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200629165000263-2051250630.png"></p><p>1、第一个类加载器的层次为：Bootstrap 称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库。</p><p>2、第二个类加载器的层次为：Extension 是用来加载扩展类的，主要负责加载Java的扩展类库,默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar包。</p><p>3、第三个类加载器的层次为：Application 又称为系统类加载器,负责在JVM启动时,加载来自在命令java中的classpath或者java.class.path系统属性或者CLASSPATH操作系统属性所指定的JAR类包和类路径。</p><p>4、第三个类加载器的层次为：CustomClassLoader(自定义加载器)  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Bootstrap加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> property.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------Ext加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property1</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> property1.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------App加载类-------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">property2</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> property2.replaceAll(<span class="string">&quot;;&quot;</span>, System.lineSeparator());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/**输出结果只截取了部分*/</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\resources.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\rt.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\sunrsasign.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jsse.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jce.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\jfr.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\classes</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext</span></span><br><span class="line">        <span class="comment">//C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line">        <span class="comment">//----------------------------------------------</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\charsets.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\deploy.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\access-bridge-64.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\cldrdata.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\dnsns.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jaccess.jar</span></span><br><span class="line">        <span class="comment">//E:\JDK\jdk1.8\jre\lib\ext\jfxrt.jar</span></span><br></pre></td></tr></table></figure><p>下图为类加载的一个全过程：<br><img src="/2019/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Jvm%E8%B0%83%E4%BC%98/%E8%AF%A6%E8%A7%A3class%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1867867-20200630084433768-1150504306.png"><br>用比较通俗的话来解释这个过程，当有一个类需要被加载时，首先要判断这个类是否已经被加载到内存中。判断加载与否的过程是自下而上的，如果class类有自己定义的类加载器，会先到CustomClassLoader 管理的cache（缓存）中去找是否已经加载，若已加载直接返回结果，否则到上层加载器ApplicationClassLoader的cache中查找，如果已经存在直接返回，如果不存在，到Extension中查找，存在直接返回，不存在继续向父加载器中寻找直到Bootstrap顶层，如果依然没找到，那就是没有加载器加载过这个类。需要委派对应的加载器来加载，上层加载器先看看这个类是否在自己的加载范围内，如果是直接加载返回结果，若不是继续向下委派，以此类推直到最下级，如果最终也没能加载，就会直接抛异常 ClassNotFoundException，这就是双亲委派模式的流程。</p><h3 id="理解双亲委派模式"><a href="#理解双亲委派模式" class="headerlink" title="理解双亲委派模式"></a>理解双亲委派模式</h3><p>1、父加载器：不是类加载器的加载器，也不是类加载器的父类加载器（此处意思是没有父类与子类之间的继承关系）。<br>通常会将 BootstrapClassLoader 称为 ExtensionClassLoader 的父加载器；<br>ExtensionClassLoader 称为 ApplicationClassLoader 的父加载器；<br>ApplicationClassLoader 称为 CustomClassLoader 的父加载器；<br>但这个父子关系并不代表着JAVA语法中的继承，而更形象的只是一种语义上的关联，实际就是ClassLoader的类中有一个成员变量parent指向了其关联的ClassLoader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证了父加载器不是加载器的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentAndChild</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//AppClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null  这里AppClassLoader的加载器不是ExtClassLoader  而是Bootstrap</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">appclassLoader</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getClass().getClassLoader();</span><br><span class="line">        System.out.println(appclassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ExtClassLoader   AppClassLoader的父加载器是ExtClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentparentparent</span> <span class="operator">=</span> ParentAndChild.class.getClassLoader().getParent().getParent().getParent();</span><br><span class="line">        System.out.println(parentparent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**输出结果*/</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@23fc625e</span></span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException at com.example.demo.classloader.ParentAndChild.main(ParentAndChild.java:22)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、双亲委派：其工作原理的是，如果一个类加载器收到了类加载请求，并不会直接去加载，而是自下而上的向顶层类加载器查找是否已经被加载了，如果被加载就不用进行加载，如果未被加载过，则会自上而下的检查是否属于自己加载的范围，如果属于则加载，如果不属于则向下委托，直到类被加载进来才能叫做成功，如果加载不成功就会抛异常classnotfoundexeption,这就叫做双亲委派。</p><p>3、为什么要搞双亲委派模式？</p><p>主要是为了安全，这里可以使用反证法，如果任何类加载器都可以把class加载到内存中，我们就可以自定义类加载器来加载Java.lang.string。在打包时可以把密码存储为String对象，偷偷摸摸的把密码发送到自己的邮箱，这样会造成安全问题。</p><h2 id="四、自定义类加载器"><a href="#四、自定义类加载器" class="headerlink" title="四、自定义类加载器"></a>四、自定义类加载器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderByHand</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = ClassLoaderByHand.class.getClassLoader().</span><br><span class="line">                loadClass(<span class="string">&quot;com.example.demo.threaddemo.juc_002.Account&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 输出结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//com.example.demo.threaddemo.juc_002.Account</span></span><br></pre></td></tr></table></figure><p>代码运行结果可以看出，若要加载一个类你只要调用classLoader中的 loadClass()方法就能把这个类加载到内存中，加载完成之后会给你返回一个Class类的对象。</p><p>在硬盘上找到这个类的源码，把它load到内存，与此同时生成一个Class对象，上述的小程序是通过 ClassLoaderByHand 找到他的加载器AppClassLoader 然后调用它的loadClass()方法，让它帮我们把 Account类加载进来，返回一个clazz对象，使用clazz.getName()方法正常返回Account类。</p><blockquote><p>什么时候我们需要自己定义去加载一个类？</p><ul><li>热部署时就是先把之前加载的类给干掉 ，然后使用的自定义类加载器来进行重新加载</li><li>spring的动态代理，一个新的class 当需要的时候就会把它load到内存中</li></ul></blockquote><h3 id="ClassLoader的源码分析"><a href="#ClassLoader的源码分析" class="headerlink" title="ClassLoader的源码分析"></a>ClassLoader的源码分析</h3><p>我们还是来看一下ClassLoader的源码，加载过程最主要的还是ClassLoader中的loaderClass()方法：</p><p> 结合上面给的类加载过程的图解一起看会更容易一些；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在加载之前先调用findLoadedClass()方法查看是否已经加载过此类</span></span><br><span class="line"><span class="comment">             * 若加载过 返回该对象</span></span><br><span class="line"><span class="comment">             * 如果未加载则返回null 进行下一步</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//判断有无父加载器 如果不为空说明还未到顶层Bootstrap递归调用loadClass()</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果没有父加载器说明调用的加载器为Bootstrap Class Loader, 在此加载器内存中查找是否已经加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若以上的操作都没成功加载此类</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//调用自己的findClass()</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义classLoader"><a href="#自定义classLoader" class="headerlink" title="自定义classLoader"></a>自定义classLoader</h3><p>1.继承ClassLoader抽象类 extends ClassLoader<br>2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int off, int len)<br>3.加密（可以对class字节码文件进行加密处理，可选）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.FileUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.log.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 继承ClassLoader抽象类 extends ClassLoader</span></span><br><span class="line"><span class="comment"> * 2.重写findClass() 方法，读取class文件，并调用defineClass()，override findClass() -&gt; defineClass(byte[] b, int</span></span><br><span class="line"><span class="comment"> * 3.加密（可以对class字节码文件进行加密处理，可选）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0B10110110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 findClass 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.myclass&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != <span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b ^ seed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//defineClass最终将二进制流转换为Class类对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对旧class文件的处理,可选，此方法中使用按位取反</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classFileBasePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classPackagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encFile</span><span class="params">(String classFileBasePath, String classPackagePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePahtWithoutSuffix</span> <span class="operator">=</span> classFileBasePath.concat(<span class="string">&quot;/&quot;</span>).concat(classPackagePath.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//旧的class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">oldFis1</span> <span class="operator">=</span> FileUtil.getInputStream(oldClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义class文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newClassFilePath</span> <span class="operator">=</span> filePahtWithoutSuffix.concat(<span class="string">&quot;.myclass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">newFos</span> <span class="operator">=</span> FileUtil.getOutputStream(newClassFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (oldFis1.read() != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//按位取反</span></span><br><span class="line">            newFos.write(b ^ seed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldFis1.close();</span><br><span class="line">        newFos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        encFile(classFileBasePath, classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> (Hello) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        h.sayHello();</span><br><span class="line"></span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l是由&#123;&#125;加载而来&quot;</span>, l.getClass().getClassLoader());</span><br><span class="line">        LogFactory.get().info(<span class="string">&quot;自定义classloader类l的父加载器是&#123;&#125;&quot;</span>, l.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、破坏双亲委派机制"><a href="#五、破坏双亲委派机制" class="headerlink" title="五、破坏双亲委派机制"></a>五、破坏双亲委派机制</h2><p>1.如何破坏双亲委派模型？</p><p>通过重写loadClass()方法。</p><p>2.什么时候破坏过双亲委派模型？</p><blockquote><ul><li>JDK1.2之前，自定义classLoader都必须重写loadClass ()方法。（缺陷）</li><li>ThreadContextClassLoader可以实现基础类调用实现类的代码</li><li>热启动/热部署  tomcat 都有自己的模块指定classLoader（可以加载同一类库的不同版本）</li></ul></blockquote><p>当下也就只能对自定义的class实现打破双亲委派的策略来加载</p><p>破坏双亲委派模型的简单实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiny.security.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义classloader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重新loadClass方法来打破双亲委派机制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by honglin.li on 2020/9/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class基础路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_BACKAGE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/workspace-for-idea/myTestWorkSpace/MySpringCloudStudy/is-user-api/target/classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_BACKAGE_PATH, name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class文件所在项目包的基本地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classFileBasePath</span> <span class="operator">=</span> BASE_BACKAGE_PATH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class类的包内路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPackagePath</span> <span class="operator">=</span> <span class="string">&quot;com.tiny.security.util.Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> l.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.tiny.security.util.Hello cannot be cast to com.tiny.security.util.Hello</span></span><br><span class="line">        <span class="comment">//Hello h1old = (Hello) clazz.newInstance();</span></span><br><span class="line">        <span class="comment">//h1old.sayHello();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h1</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h1.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在此处断点后，修改hello方法中的输出内容，并重新编译生成新的class</span></span><br><span class="line"><span class="comment">            观察两次输出的内容,可以判定class是否被重新加载了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> l2.loadClass(classPackagePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">h2</span> <span class="operator">=</span> JSON.parseObject(JSON.toJSONString(clazz2.newInstance()), Hello.class);</span><br><span class="line"></span><br><span class="line">        h2.sayHello();</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>原文/参考链接<br>calss 加载过程: <a href="https://www.cnblogs.com/dongl961230/p/13212080.html">https://www.cnblogs.com/dongl961230/p/13212080.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JVM调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区域截图异常问题排查</title>
      <link href="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>上个月开发了一个业务功能，整体的流程是通过配置的定时任务，在触发时刻将使用谷歌的爬虫工具selenium在后台通过用户的身份登录公司的报表系统门户中，查看配置的某些报表，进行截图后将图片信息结合配置的内容排版，通过邮件发送到用户邮箱中。就是这样一个简单的需求，但缺因为自己的不细心不自信，加上连续遇上了两个外部jar包的bug，耗费了一整天的时间还加班到凌晨。</p><span id="more"></span><p>区域截图的处理示意图<br><img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595324550060.png"></p><ol><li>打开报表时，先定位div元素的起点坐标和元素宽高，并截取全屏的图片</li><li>使用区域截图的方法结合第1步记录的信息，只截取报表展示区域的图片内容</li></ol><h2 id="异常描述"><a href="#异常描述" class="headerlink" title="异常描述"></a>异常描述</h2><p>原本简单的截图需求，在多次使用截图方法后，输出的截图文件却始终不合规范。</p><h3 id="代码贴图"><a href="#代码贴图" class="headerlink" title="代码贴图"></a>代码贴图</h3><ol><li>通过谷歌浏览器驱动进行截图的代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取多张管理画布的截图页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName  登录用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> passWord  用户密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reportIdList  需要查看的管理画布报表的id列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, File&gt; <span class="title function_">dataexplorScreenShotMap</span><span class="params">(String userName, String passWord, List&lt;String&gt; reportIdList)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置驱动地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">driverPath</span> <span class="operator">=</span> getChromeDriverPathByOs();</span><br><span class="line"></span><br><span class="line">    HtmlScreenshotSettingParam.settingParamInit();</span><br><span class="line"></span><br><span class="line">    System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, driverPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">ChromeOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeOptions</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是要执行的命令，不打开浏览器窗口的方式，如需修改截图页面的尺寸，修改--window-size的参数即可</span></span><br><span class="line">    options.addArguments(</span><br><span class="line">            <span class="string">&quot;--headless&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--disable-gpu&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--ignore-certificate-errors&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定模拟打开浏览器的窗口的宽高</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;--window-size=1440,1200&quot;</span>;</span><br><span class="line"></span><br><span class="line">    options.addArguments(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 先进行登录</span></span><br><span class="line">    <span class="type">WebDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeDriver</span>(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问页面</span></span><br><span class="line">    driver.get(HtmlScreenshotSettingParam.DAP_LOGIN_PAGE_URL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//账号密码，按钮  ，直接模拟登录</span></span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;login_name&quot;</span>)).sendKeys(userName);</span><br><span class="line"></span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;user_cipher&quot;</span>)).sendKeys(passWord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟点击登录按钮</span></span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;btnSubmit&quot;</span>)).click();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定等待时间供连接访问</span></span><br><span class="line">    Thread.sleep(HtmlScreenshotSettingParam.PAGE_LOADING_WAITING_TIME);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; ImageMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, File&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String canvasReportId : reportIdList) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结合报表的id，构造报表的展示地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reportUrl</span> <span class="operator">=</span> HtmlScreenshotSettingParam.CANVAS_REPORT_MODEL_URL.replace(<span class="string">&quot;&#123;reportId&#125;&quot;</span>, canvasReportId);</span><br><span class="line"></span><br><span class="line">        driver.get(reportUrl);</span><br><span class="line"></span><br><span class="line">        driver.navigate().refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.登录后访问报表地址</span></span><br><span class="line">        logger.info(<span class="string">&quot;当前展示的页签名称:&quot;</span> + driver.getTitle());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(HtmlScreenshotSettingParam.PAGE_LOADING_WAITING_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到截图的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">screenshotFile</span> <span class="operator">=</span> ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换格式</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">screenshotFormatFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>( screenshotFile.getPath().replace(<span class="string">&quot;.png&quot;</span>, HtmlScreenshotSettingParam.ImageFormat));</span><br><span class="line"></span><br><span class="line">        ImgUtil.convert(screenshotFile, screenshotFormatFile);</span><br><span class="line"></span><br><span class="line">        screenshotFile = screenshotFormatFile;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图,只获取管理画布内容</span></span><br><span class="line">        screenshotFile = regionalScreenshots(driver, screenshotFile);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((screenshotFile != <span class="literal">null</span>) &amp;&amp; screenshotFile.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            ImageMap.put(canvasReportId, screenshotFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver.quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ImageMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>区域截图的处理逻辑方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile 完整的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;进入画布的区域截图方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                + screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制完整的图片文件</span></span><br><span class="line">        FileUtils.copyFile(screenshotFile, cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找画布div节点</span></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//矩形图像对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x、y表示加上当前frame的左边距,上边距</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">dest</span> <span class="operator">=</span> image.getSubimage(point.x, point.y, rect.width, rect.height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写出截图文件</span></span><br><span class="line">        ImageIO.write(dest, <span class="string">&quot;png&quot;</span>, cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + cacheShotPic.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheShotPic;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常规登录页面获取管理画布</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataexplorScreenShotMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;cw&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">passWord</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String[] reportIdArr = &#123;&quot;24160932063991478208&quot;, &quot;50582076917040768340&quot;, &quot;50570813594059717529&quot;&#125;;</span></span><br><span class="line">    String[] reportIdArr = &#123;<span class="string">&quot;243945938171462886942&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; reportIdList = Arrays.asList(reportIdArr);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; imageMap = HtmlScreenshotUtil.dataexplorScreenShotMap( userName, passWord, reportIdList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;调用工具类后,取得截图文件:&quot;</span> + imageMap.keySet().size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key : imageMap.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">imageFile</span> <span class="operator">=</span> imageMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/&quot;</span> + key + <span class="string">&quot;_&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">            FileUtil.copy(imageFile, <span class="keyword">new</span> <span class="title class_">File</span>(pathname));</span><br><span class="line"></span><br><span class="line">            System.out.println(pathname);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>截取的图片文件预览</li></ol><ul><li>完整截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot4011539626072935834_complete_20200721205449.jpg"></li><li>区域截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/243945938171462886942_1595335555972.png"></li></ul><p>这显然不是我们想要的结果,  但是本人从代码层面没有发现明显的异常。也是由于工作中对图片的处理用的比较少，不太确定代码的正确性。</p><h2 id="试错过程"><a href="#试错过程" class="headerlink" title="试错过程"></a>试错过程</h2><p>由于没能找到当前代码中的异常，于是换了其他的处理逻辑。想起此前领导案例的一个”优秀的”第三方工具包hutool，查看其文档后，发现其中也有图片处理的方法，maven引用也很便捷。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-captcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hutool 中包含两个类似的图片工具类</p><ul><li><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片工具-ImgUtil">图片工具-ImgUtil</a></li><li><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片编辑器-Img">图片编辑器-Img</a></li></ul><p>阅读相关的文档并，我选择了图片编辑器中的图像切割，因为后续也会使用到图片的缩放，链式调用使得代码很简洁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"><span class="comment">//矩形裁剪</span></span><br><span class="line">    .cut(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height))</span><br><span class="line"><span class="comment">//缩放</span></span><br><span class="line">    .scale(<span class="number">900</span>,<span class="number">600</span>)</span><br><span class="line"><span class="comment">//写出</span></span><br><span class="line">    .write(FileUtil.file(screenshotFile));</span><br></pre></td></tr></table></figure><h3 id="使用hutool-图片编辑器裁剪图片"><a href="#使用hutool-图片编辑器裁剪图片" class="headerlink" title="使用hutool-图片编辑器裁剪图片"></a>使用hutool-图片编辑器裁剪图片</h3><ol><li>修改后的区域截图方法代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容 - 使用hutool 的图片编辑器进行裁剪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                +screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的全屏文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheCompletePic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"></span><br><span class="line">                .cut(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height))</span><br><span class="line"></span><br><span class="line">                .scale(HtmlScreenshotSettingParam.canvasScaleWidth, HtmlScreenshotSettingParam.canvasScaleHighth)</span><br><span class="line"></span><br><span class="line">                .write(FileUtil.file(screenshotFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的区域截图文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheShotPic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试方法运行图效果</li></ol><ul><li><p>完整截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot263478830502424703_complete_20200722100018.jpg"></p></li><li><p>区域截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/screenshot263478830502424703_shot_20200722100018.jpg"><br>同样，截图的区域不是预期的效果。而且对于相同的矩形起点和宽高，为何两种方案截图出来的效果都不一致？真叫人头大。</p></li></ul><h3 id="穷举测试"><a href="#穷举测试" class="headerlink" title="穷举测试"></a>穷举测试</h3><p>我开始破罐子破摔的方式，手动调整截图的起点和范围。试想的方案是，使用之前存下来的全屏的图片文件,  本地编写矩形区域的真实宽高，重复尝试着确认起始点的坐标，观察截图文件的内容。<br>此时已经变更截图方法为 hutool-图片编辑器 的截图方法，故以此编写了测试类</p><ol><li>正常宽高测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/画布div起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, width, highth);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle1)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/原点起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试效果图</p><ul><li><p>以画布坐标为起点的截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E7%94%BB%E5%B8%83div%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li><li><p>以原点坐标为起点的截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8E%9F%E7%82%B9%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li></ul><p>几张图片的尺寸是一致的，但是实际截取的范围都比画布的尺寸更小。甚至原点都不在图片文件的左上顶点。于是我决定把宽高的范围手动扩大，观察效果。</p><ol start="2"><li>设定双倍宽高<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutDoubleTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width * <span class="number">2</span>, highth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/双倍画布div起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, <span class="number">0</span>, width * <span class="number">2</span>, highth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Img.from(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>))</span><br><span class="line">            .cut(rectangle1)</span><br><span class="line">            .write(cn.hutool.core.io.FileUtil.file(<span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/双倍原点起点截图.png&quot;</span>))</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试效果图</li></ol><ul><li><p>以画布坐标为起点的截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E7%94%BB%E5%B8%83div%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li><li><p>以原点坐标为起点的截图<br>  <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E5%8E%9F%E7%82%B9%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p></li></ul><p>看到第二张图的效果，除了顶部的灰色条，几乎都完美的解决了我的问题。再次尝试修改坐标位置，截取得到了只包含画布的微调截图范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从原点开始截图(0,0)</span></span><br><span class="line"><span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">0</span>, y, width * <span class="number">2</span>, highth * <span class="number">2</span> - y);</span><br></pre></td></tr></table></figure><p>效果图<br><img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%8F%8C%E5%80%8D%E5%8E%9F%E7%82%B9%E5%BE%AE%E8%B0%83%E8%B5%B7%E7%82%B9%E6%88%AA%E5%9B%BE.png"></p><p>由于需要赶进度，就按照这种改动设定了宽高和坐标轴，对代码进行了提交。此时对截取的范围的选择和理解，依旧和java的截图矩形类的定义不一致 ，逻辑上其实是不正确的。<br>而代码提交后，交付到运维同事，他本地拉取代码部署运行后。通过邮件接收到的截图内容，简直堪称离谱。和我本地的测试效果完全不一样。<br><img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595396629702.png"></p><h3 id="补全日志信息"><a href="#补全日志信息" class="headerlink" title="补全日志信息"></a>补全日志信息</h3><p>我确定代码是一致的，但是运行效果的差异，这让我意识到也许和操作系统环境有关。我本地使用mac系统，同时用的windows机器，部署上线的又是linux系统中。由于最初编码的时候，实际并没有上述代码块中那么多详细的日志，为了对比具体的执行差异，才在方法中补全了足够详细的日志记录。 也翻出了我家里的老伙计，辅助做印证测试。</p><p>mac上执行截图的测试方法,从控制台看到本次执行过程打印的日志</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">42</span>,<span class="number">402</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">252</span> - 当前展示的页签名称:<span class="number">2020</span>进阶趋势 › page1</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">358</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">613</span> - 进入画布的区域截图方法</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">374</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">643</span> - 留存当前图片的全屏内容,存放位置 /<span class="symbol">Users</span>/buqiugouda/.oldsemf/chromedriver/screenshot/screenshot5254156389223784299_complete_20200722135053.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">460</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">647</span> - 当前全屏文件的宽度:<span class="number">2880</span> 高度:<span class="number">2400</span></span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">478</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">654</span> - 当前全屏文件包含了画布的区域,起点坐标(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">53</span>,<span class="number">489</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">661</span> - 当前画布内容的宽度:<span class="number">840</span> 高度:<span class="number">1190</span></span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">54</span>,<span class="number">045</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">675</span> - 留存当前图片的区域截图内容,存放位置 /<span class="symbol">Users</span>/buqiugouda/.oldsemf/chromedriver/screenshot/screenshot5254156389223784299_shot_20200722135053.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">50</span>:<span class="number">54</span>,<span class="number">054</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">679</span> - 当前区域截图文件经过指定尺寸缩放后的宽度:<span class="number">800</span> 高度:<span class="number">900</span></span><br></pre></td></tr></table></figure><p>windows上执行截图测试方法，从控制台看到本次执行过程打印的日志</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">04</span>,<span class="number">778</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">252</span> - 当前展示的页签名称:<span class="number">2020</span>进阶趋势 › page1</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">265</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">613</span> - 进入画布的区域截图方法</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">272</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">643</span> - 留存当前图片的全屏内容,存放位置 <span class="symbol">D</span>:\\oldsemf\chromedriver\screenshot\screenshot2057483932069022115_complete_20200722135711.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">355</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">647</span> - 当前全屏文件的宽度:<span class="number">1440</span> 高度:<span class="number">1200</span></span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">373</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">654</span> - 当前全屏文件包含了画布的区域,起点坐标(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">385</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">661</span> - 当前画布内容的宽度:<span class="number">840</span> 高度:<span class="number">1190</span></span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">901</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">675</span> - 留存当前图片的区域截图内容,存放位置 <span class="symbol">D</span>:\\oldsemf\chromedriver\screenshot\screenshot2057483932069022115_shot_20200722135711.jpg</span><br><span class="line"><span class="number">13</span>:<span class="number">57</span>:<span class="number">11</span>,<span class="number">908</span>  <span class="symbol">INFO</span> <span class="symbol">HtmlScreenshotUtil</span>:<span class="number">679</span> - 当前区域截图文件经过指定尺寸缩放后的宽度:<span class="number">800</span> 高度:<span class="number">900</span></span><br></pre></td></tr></table></figure><p>重点落在首次截取的全屏图片文件的宽高上，mac上截得文件的宽高居然是windows上的两倍。而我在代码中调用谷歌驱动时，分明指定了模拟浏览器打开时，窗口的宽高为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定模拟打开浏览器的窗口的宽高</span></span><br><span class="line"><span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;--window-size=1440,1200&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>这就说明mac截图下来的文件，自行将图片宽高扩大了一倍！当然这个bug，谷歌浏览器驱动包 selenium-chrome-driver 依赖jar包中的截图方法，与当前mac 系统的版本号，我安装的浏览器版本 更具体的对应关系是否有关就不得而知。</strong></p><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><p>新编写一个测试类，将历史测试数据中的完整截图先等比缩放以后再进行矩形区域的截图。<br>使用hutool 图片编辑器提供的缩放裁剪链式调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍 - 再进行截图</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).cut(rectangle).write(cacheShotPic);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图<br>    <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595405941568.png"></p><p>(几近崩快，居然还是没能正确地截取！！！)</p><h3 id="对比测试"><a href="#对比测试" class="headerlink" title="对比测试"></a>对比测试</h3><p>既然出现了 selenium-chrome-driver 外部依赖的bug，完全有理由怀疑 hutool 提供的截图方法存在bug.<br>使用java的 BufferedImage 的截取方法进行截取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompleteScalePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图-等比缩放.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompleteScalePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).write(cacheCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">img</span> <span class="operator">=</span> ImageIO.read(cacheCompleteScalePic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在缩放后的图片上指定范围来截图</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">dest</span> <span class="operator">=</span> img.getSubimage(x, y , width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    ImageIO.write(dest, <span class="string">&quot;png&quot;</span>, cacheShotPic);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图<br>    <img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595406306543.png"></p><p>是的，这足以证明hutool的 <a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片编辑器-Img">图片编辑器-Img</a> 中提供的.cut() 的矩形截图方法是存在bug的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自此已经明确找出两处bug和他们的影响，通过windows机器上的对比可确定解决方案。mac系统上截取的全屏图片由于被拉伸，所以在区域截图前应当先缩放，在用指定的矩形范围和坐标进行截图。最终验证测试了hutool的另一个图片处理工具<br><a href="https://hutool.cn/docs/#/core/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-ImgUtil" title="图片工具-ImgUtil">图片工具-ImgUtil</a> ，发现其矩形截图方法.cut()是同BufferedImage.getSubimage()原理一致的。<br>使用hutool的图片工具ImgUtil编写的测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pagecutTest3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(300,15)是之前断点调试时，获取得到的div元素的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画布div的宽</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">840</span>;</span><br><span class="line">    <span class="comment">//画布div的高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highth</span> <span class="operator">=</span> <span class="number">1190</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/完整的图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> <span class="string">&quot;/Volumes/资料盘/我的文档/业务信息图/mac拉伸后对应截取方案图.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, width, highth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等比缩放0.5倍</span></span><br><span class="line">    Img.from(cacheCompletePic).scale(<span class="number">0.5f</span>).write(cacheShotPic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//截取</span></span><br><span class="line">    ImgUtil.cut(cacheCompletePic, cacheShotPic, rectangle);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果图</p><p><img src="/2019/07/21/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/%E5%8C%BA%E5%9F%9F%E6%88%AA%E5%9B%BE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1595407306025.png"></p><p>变更区域截图的处理逻辑方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的管理画布页面截取核心内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenshotFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">regionalScreenshots0</span><span class="params">(WebDriver driver, File screenshotFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;进入画布的区域截图方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在驱动目录新建一个文件夹用以保存截图文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">customPicSavePath</span> <span class="operator">=</span> AppContextMap.get(<span class="string">&quot;chrome.dirver&quot;</span>) + <span class="string">&quot;/screenshot&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(customPicSavePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!parentPath.exists()) &#123;</span><br><span class="line"></span><br><span class="line">            parentPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">timeInfo</span> <span class="operator">=</span> MyStringUtils.getStringDateFmt(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonFilePath</span> <span class="operator">=</span> customPicSavePath + <span class="string">&quot;/&quot;</span></span><br><span class="line">                +screenshotFile.getName().substring(<span class="number">0</span>, screenshotFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveCompletePic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_complete_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">saveShotPic</span> <span class="operator">=</span> commonFilePath + <span class="string">&quot;_shot_&quot;</span> + timeInfo + HtmlScreenshotSettingParam.ImageFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完整的截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheCompletePic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区域截图文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">cacheShotPic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveShotPic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的全屏文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheCompletePic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的全屏内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> ImgUtil.read(cacheCompletePic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件的宽度:&quot;</span> + image.getWidth() + <span class="string">&quot; 高度:&quot;</span> + image.getHeight());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//浏览器窗口的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowWidth</span> <span class="operator">=</span> driver.manage().window().getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//浏览器窗口的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowHeight</span> <span class="operator">=</span> driver.manage().window().getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把全屏文件的尺寸缩放到与设定窗口的宽高一致，调整图片尺寸后续再截图</span></span><br><span class="line">        Img.from(screenshotFile)</span><br><span class="line">                .scale(windowWidth, windowHeight)</span><br><span class="line">                .write(screenshotFile);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebElement</span> <span class="variable">element</span> <span class="operator">=</span> driver.findElement(By.className(<span class="string">&quot;graticule&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素在所处frame中位置对象</span></span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> element.getLocation();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前全屏文件包含了画布的区域,起点坐标(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素的宽与高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> element.getSize().getWidth();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> element.getSize().getHeight();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前画布内容的宽度:&quot;</span> + width + <span class="string">&quot; 高度:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//截图</span></span><br><span class="line">        ImgUtil.cut(screenshotFile, screenshotFile, <span class="keyword">new</span> <span class="title class_">Rectangle</span>(point.x, point.y, width, height));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放</span></span><br><span class="line">        Img.from(FileUtil.file(screenshotFile))</span><br><span class="line"></span><br><span class="line">                .scale(HtmlScreenshotSettingParam.canvasScaleWidth, HtmlScreenshotSettingParam.canvasScaleHighth)</span><br><span class="line"></span><br><span class="line">                .write(FileUtil.file(screenshotFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录暂存的区域截图文件</span></span><br><span class="line">        FileUtil.copy(screenshotFile, cacheShotPic, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;留存当前图片的区域截图内容,存放位置 &quot;</span> + saveCompletePic);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">shotImage</span> <span class="operator">=</span> ImgUtil.read(cacheShotPic);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;当前区域截图文件经过指定尺寸缩放后的宽度:&quot;</span> + shotImage.getWidth() + <span class="string">&quot; 高度:&quot;</span> + shotImage.getHeight());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;未能对指定图片进行区域截图&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screenshotFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ol><li>对图片处理的原生方法使用太少，未能根据截取效果第一时间判断，自己是否对矩形范围的坐标和宽高设定有误。</li><li>外部驱动的使用有时候因为技术方案或者业务需求无法变动，但都需要做足够详细的技术验证和测试工作。否则开发工程中的意外试错，将会影响工作效率和进度</li><li>外部的工具包虽然是大牛编写的，但也并不能预知所有的情况。对工具的使用，并不该只停在”拿来主义”，看看它的源码，也能对自己有所帮助。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作踩坑 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot-静态页面无法加载</title>
      <link href="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前段时间帮项目上的同事改造一个springboot项目，后端使用springboot框架开发，前端使用node.js编译后将静态资源放到后端自行新增的webapp目录下,  又套用了web.xml等一系列配置将项目改造成了web项目,最终以war包形式进行发布。  </p><span id="more"></span><p>本人的任务是为此项目接入统一认证的平台，使用了已经验证过的拦截器，来实现登录的会话验证。强迫症让我又将项目结构调整为普通的springboot的结构。</p><p>在添加完拦截器之后，后端接口测试基本都一次过,拦截器的逻辑也都符合预期。但是加入静态资源后，进入主页却始终无法引用到相关的静态资源。</p><p><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%BC%82%E5%B8%B8%E4%B8%BB%E9%A1%B50.png"></p><p>而所有单独请求静态资源的url都返回404，查看idea 发现以下日志记录<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%AA%E8%AF%86%E5%88%AB7a3a0a8a.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p> 静态文件结构:<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84f978d5f6.png"></p><p>前端页面的解析使用sprinboot提供的thymeleaf,并在配置文件中完成配置。<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/thymeleaf%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%901e5a6d02.png"></p><h2 id="解决问题的流程"><a href="#解决问题的流程" class="headerlink" title="解决问题的流程"></a>解决问题的流程</h2><h3 id="排查资源编译路径"><a href="#排查资源编译路径" class="headerlink" title="排查资源编译路径"></a>排查资源编译路径</h3><p>最初只是注意到页面的空白，以及idea的日志记录，百度后就认定为静态资源无法读取。<br>重新maven编译后，确认target的同目录结构下，是存在相关静态资源的，于是排除了编译问题。</p><h3 id="排查springboot关于静态文件的读取配置"><a href="#排查springboot关于静态文件的读取配置" class="headerlink" title="排查springboot关于静态文件的读取配置"></a>排查springboot关于静态文件的读取配置</h3><p>由于接触的项目跨度比较大，从jsp之后，经手的项目都是前后端分离的。所以去网络上查找也学习了关于静态文件的配置方法。</p><p>参考此文档后 <a href="https://www.jianshu.com/p/a9e6edd46e98">https://www.jianshu.com/p/a9e6edd46e98</a> ,算是理清了静态文件资源的读取规则。<br>于是满怀信心后添加配置<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/springboot%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AEa206d7fd.png"></p><p>但页面依旧没有任何变化。冷静查看 spring.resources.static-locations 指向的默认配置类<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE7a27e960.png"><br>而我的项目中，存放静态资源的位置，本来就位于其中,加上sprongboot默认的静态资源匹配规则就是 /**, 其实我这个项目压根就用不着额外配置</p><p>继续翻阅文章是，注意到springboot早起的版本，对于静态资源的放行，不是直接配置而是放到了拦截器中进行处理。正好我做会话认证的功能也是写在自定义拦截器的实现类中,于是仿写了相关配置在拦截器中进行静态资源的匹配和处理规则。<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BBe33b5431.png"></p><p>再次打开项目，进入主页时，异常居然就解决了。<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%BB%E9%A1%B5dbf500e7.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>再次审阅我的自定义”拦截器”<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%94%AF%E4%B8%80%E9%85%8D%E7%BD%AE%E7%B1%BB3f5855e9.png"></p><p>等等为什么这个类 是在继承 WebMvcConfigurationSupport, 我的其他项目中使用拦截器似乎有点不同。<br><img src="/2019/07/01/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91/springboot-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8567273b7.png"><br>其他项目中使用的都是 WebMvcConfigurer的自定义实现类</p><p>继续搜索了相关资料后, 了解了WebMvcConfigurationSupport 和 WebMvcConfigurer 的区别和关联<br>参考链接: <a href="https://www.jianshu.com/p/c5c1503f5367">https://www.jianshu.com/p/c5c1503f5367</a></p><p>WebMvcConfigurationSupport 在整个应用程序中只会生效一个，如果用户已经实现了 WebMvcConfigurationSupport，则 DelegatingWebMvcConfiguration 将不会生效。换句话来说，WebMvcConfigurer 的所有实现类将不会生效。<br>而在Spring 中，如果类路径上不存在 WebMvcConfigurationSupport 的实例，则将会默认实现WebMvcConfigurerAdapter、DelegatingWebMvcConfiguration 来自定义mvc 配置。</p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>对于我本次改造的项目而言,静态文件的存放路径就在springboot的默认配置路径中,不要额外指定和配置。只需要修改拦截器的实现类，使用 WebMvcConfigurer 的自定义实现类来定义会话拦截器就可以了。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2>]]></content>
      
      
      <categories>
          
          <category> 工作踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
